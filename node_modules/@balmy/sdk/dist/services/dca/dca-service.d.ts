import { Address, ChainId, TokenAddress, BuiltTransaction, TimeString } from '../../types';
import { SinglePermitParams, PermitData, IPermit2Service } from '../permit2';
import { IQuoteService } from '../quotes';
import { CreateDCAPositionParams, DCASwapInterval, SupportedDCAToken, IDCAService, IncreaseDCAPositionParams, MigrateDCAPositionParams, ReduceDCAPositionParams, ReduceToBuyDCAPositionParams, SupportedPair, TerminateDCAPositionParams, TokenVariant, WithdrawDCAPositionParams, PositionSummary, TokenVariantId } from './types';
import { IFetchService } from '../fetch';
import { IPriceService } from '../prices';
import { IProviderService } from '..';
export declare class DCAService implements IDCAService {
    private readonly apiUrl;
    private readonly providerService;
    private readonly permit2Service;
    private readonly quoteService;
    private readonly fetchService;
    private readonly priceService;
    constructor(apiUrl: string, providerService: IProviderService, permit2Service: IPermit2Service, quoteService: IQuoteService, fetchService: IFetchService, priceService: IPriceService);
    getAllowanceTarget({ chainId, from, depositWith, usePermit2, }: {
        chainId: ChainId;
        from: TokenAddress;
        depositWith: TokenAddress;
        usePermit2?: boolean;
    }): Address;
    preparePermitData(args: SinglePermitParams): Promise<PermitData>;
    buildCreatePositionTx({ chainId, from, to, swapInterval, amountOfSwaps, owner, permissions, deposit, }: CreateDCAPositionParams): Promise<BuiltTransaction>;
    buildIncreasePositionTx({ chainId, positionId, increase, amountOfSwaps, permissionPermit, dcaHub, }: IncreaseDCAPositionParams): Promise<BuiltTransaction>;
    buildReducePositionTx({ chainId, positionId, amountOfSwaps, reduce, recipient, permissionPermit, dcaHub, }: ReduceDCAPositionParams): Promise<BuiltTransaction>;
    buildReduceToBuyPositionTx({ chainId, positionId, amountOfSwaps, reduce, recipient, permissionPermit, dcaHub, }: ReduceToBuyDCAPositionParams): Promise<BuiltTransaction>;
    buildWithdrawPositionTx({ chainId, positionId, withdraw, recipient, permissionPermit, dcaHub, }: WithdrawDCAPositionParams): Promise<BuiltTransaction>;
    buildTerminatePositionTx({ chainId, positionId, withdraw, recipient, permissionPermit, dcaHub, }: TerminateDCAPositionParams): Promise<BuiltTransaction>;
    buildMigratePositionTx({ chainId, sourceHub, targetHub, positionId, migration, permissionPermit, }: MigrateDCAPositionParams): Promise<BuiltTransaction>;
    getSupportedPairs(args?: {
        chains?: ChainId[];
        config?: {
            timeout?: TimeString;
        };
    }): Promise<Record<number, {
        pairs: SupportedPair[];
        tokens: Record<TokenAddress, SupportedDCAToken>;
    }>>;
    getPositionsByAccount({ accounts, chains, includeHistory, config, }: {
        accounts: Address[];
        chains?: ChainId[];
        includeHistory?: boolean;
        config?: {
            timeout?: TimeString;
        };
    }): Promise<Record<number, PositionSummary[]>>;
    getPositionsById({ ids, includeHistory, config, }: {
        ids: {
            chainId: ChainId;
            hub: Address;
            positionId: number;
        }[];
        includeHistory?: boolean;
        config?: {
            timeout: TimeString;
        };
    }): Promise<Record<ChainId, PositionSummary[]>>;
    getPairSwaps({ chainId, variantTokenA, variantTokenB, config, }: {
        chainId: ChainId;
        variantTokenA: TokenVariantId;
        variantTokenB: TokenVariantId;
        config?: {
            timeout: TimeString;
        };
    }): Promise<{
        tokenA: TokenInPair;
        tokenB: TokenInPair;
        swaps: {
            ratioAToB: bigint;
            ratioBToA: bigint;
            ratioAToBWithFee: bigint;
            ratioBToAWithFee: bigint;
            intervalsInSwap: DCASwapInterval[];
            executedAt: number;
        }[];
    }>;
    private fetchPositions;
    private getSwapData;
    private getUserPosition;
}
type TokenInPair = {
    address: TokenAddress;
    symbol: string;
    decimals: number;
    name: string;
    price?: number;
    variant: TokenVariant;
};
export {};
