"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DCAService = void 0;
const qs_1 = __importDefault(require("qs"));
const viem_1 = require("viem");
const companion_1 = __importDefault(require("../../shared/abis/companion"));
const dca_hub_1 = __importDefault(require("../../shared/abis/dca-hub"));
const config_1 = require("../permit2/utils/config");
const utils_1 = require("../../shared/utils");
const constants_1 = require("../../shared/constants");
const types_1 = require("./types");
const config_2 = require("./config");
const erc721_1 = __importDefault(require("../../shared/abis/erc721"));
const utils_2 = require("../providers/utils");
const _chains_1 = require("../../chains");
class DCAService {
    constructor(apiUrl, providerService, permit2Service, quoteService, fetchService, priceService) {
        this.apiUrl = apiUrl;
        this.providerService = providerService;
        this.permit2Service = permit2Service;
        this.quoteService = quoteService;
        this.fetchService = fetchService;
        this.priceService = priceService;
    }
    getAllowanceTarget({ chainId, from, depositWith, usePermit2, }) {
        if (usePermit2) {
            return config_1.PERMIT2_CONTRACT.address(chainId);
        }
        else if ((0, utils_1.isSameAddress)(from, depositWith)) {
            return config_2.DCA_HUB_CONTRACT.address(chainId);
        }
        else {
            return config_2.COMPANION_CONTRACT.address(chainId);
        }
    }
    preparePermitData(args) {
        return this.permit2Service.preparePermitData({ ...args, spender: config_2.COMPANION_CONTRACT.address(args.chainId) });
    }
    async buildCreatePositionTx({ chainId, from, to, swapInterval, amountOfSwaps, owner, permissions, deposit, }) {
        let depositInfo;
        if ('token' in deposit) {
            const amount = BigInt(deposit.amount);
            depositInfo = { token: deposit.token, amount, value: (0, utils_1.isSameAddress)(deposit.token, constants_1.Addresses.NATIVE_TOKEN) ? amount : 0n };
        }
        else {
            depositInfo = { token: deposit.permitData.token, amount: BigInt(deposit.permitData.amount), value: 0n };
        }
        const needsSwap = !(0, utils_1.isSameAddress)(depositInfo.token, from.variantId);
        if ('token' in deposit && !needsSwap) {
            // If don't need to use Permit2, then just call the hub
            return {
                to: config_2.DCA_HUB_CONTRACT.address(chainId),
                data: (0, viem_1.encodeFunctionData)({
                    abi: dca_hub_1.default,
                    functionName: 'deposit',
                    args: [
                        from.variantId,
                        to.variantId,
                        depositInfo.amount,
                        amountOfSwaps,
                        swapInterval,
                        owner,
                        permissions.map(({ operator, permissions }) => ({
                            operator: operator,
                            permissions: permissions.map(mapPermission),
                        })),
                    ],
                }),
            };
        }
        // If we get to this point, then we'll use the Companion for the deposit
        const calls = [];
        // Handle take from caller (if necessary)
        const recipient = needsSwap ? config_2.COMPANION_SWAPPER_CONTRACT.address(chainId) : config_2.COMPANION_CONTRACT.address(chainId);
        if ('permitData' in deposit) {
            calls.push(buildTakeFromCallerWithPermit(deposit.permitData, deposit.signature, recipient));
        }
        else if (!(0, utils_1.isSameAddress)(depositInfo.token, constants_1.Addresses.NATIVE_TOKEN)) {
            calls.push(buildTakeFromCaller(depositInfo.token, depositInfo.amount, recipient));
        }
        // Handle swap
        if (needsSwap) {
            const { swapData } = await this.getSwapData({
                request: {
                    chainId,
                    sellToken: depositInfo.token,
                    buyToken: from.variantId,
                    order: { type: 'sell', sellAmount: depositInfo.amount },
                },
                leftoverRecipient: owner,
                swapConfig: deposit?.swapConfig,
            });
            calls.push(swapData);
        }
        // Handle deposit
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'depositWithBalanceOnContract',
            args: [
                config_2.DCA_HUB_CONTRACT.address(chainId),
                from.variantId,
                to.variantId,
                amountOfSwaps,
                swapInterval,
                owner,
                permissions.map(({ operator, permissions }) => ({
                    operator: operator,
                    permissions: permissions.map(mapPermission),
                })),
                '0x',
            ],
        }));
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls, value: depositInfo.value });
    }
    async buildIncreasePositionTx({ chainId, positionId, increase, amountOfSwaps, permissionPermit, dcaHub, }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_CONTRACT.address(chainId);
        let increaseInfo;
        if (!increase) {
            increaseInfo = { token: constants_1.Addresses.ZERO_ADDRESS, amount: 0n, value: 0n };
        }
        else if ('token' in increase) {
            const amount = BigInt(increase.amount);
            increaseInfo = { token: increase.token, amount, value: (0, utils_1.isSameAddress)(increase.token, constants_1.Addresses.NATIVE_TOKEN) ? amount : 0n };
        }
        else {
            increaseInfo = { token: increase.permitData.token, amount: BigInt(increase.permitData.amount), value: 0n };
        }
        const bigIntPositionId = BigInt(positionId);
        const [positionOwner, position] = await this.providerService.getViemPublicClient({ chainId }).multicall({
            contracts: [
                { abi: erc721_1.default, address: config_2.DCA_PERMISSION_MANAGER_CONTRACT.address(chainId), functionName: 'ownerOf', args: [bigIntPositionId] },
                { abi: dca_hub_1.default, address: hubAddress, functionName: 'userPosition', args: [bigIntPositionId] },
            ],
            allowFailure: false,
            multicallAddress: utils_2.MULTICALL_CONTRACT.address(chainId),
            batchSize: 0,
        });
        const needsSwap = !(0, utils_1.isSameAddress)(increaseInfo.token, position.from);
        const callHubDirectly = !increase || increaseInfo.amount === 0n || amountOfSwaps === 0 || ('token' in increase && !needsSwap);
        if (callHubDirectly) {
            // If don't need to use Permit2, then just call the hub
            return {
                to: hubAddress,
                data: (0, viem_1.encodeFunctionData)({
                    abi: dca_hub_1.default,
                    functionName: 'increasePosition',
                    args: [BigInt(positionId), BigInt(increaseInfo.amount), amountOfSwaps],
                }),
            };
        }
        // If we get to this point, then we'll use the Companion for the increase
        const calls = [];
        const recipient = needsSwap ? config_2.COMPANION_SWAPPER_CONTRACT.address(chainId) : config_2.COMPANION_CONTRACT.address(chainId);
        if ('permitData' in increase) {
            // Handle take from caller (if necessary)
            calls.push(buildTakeFromCallerWithPermit(increase.permitData, increase.signature, recipient));
        }
        else if (!(0, utils_1.isSameAddress)(increaseInfo.token, constants_1.Addresses.NATIVE_TOKEN)) {
            calls.push(buildTakeFromCaller(increaseInfo.token, increaseInfo.amount, recipient));
        }
        if (needsSwap) {
            const { swapData } = await this.getSwapData({
                request: {
                    chainId,
                    sellToken: increaseInfo.token,
                    buyToken: position.from,
                    order: { type: 'sell', sellAmount: increaseInfo.amount },
                },
                leftoverRecipient: positionOwner,
                swapConfig: increase?.swapConfig,
            });
            calls.push(swapData);
        }
        // Handle permission permit
        if (permissionPermit) {
            calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        // Handle increase
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'increasePositionWithBalanceOnContract',
            args: [hubAddress, bigIntPositionId, amountOfSwaps],
        }));
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls, value: increaseInfo?.value });
    }
    async buildReducePositionTx({ chainId, positionId, amountOfSwaps, reduce, recipient, permissionPermit, dcaHub, }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_CONTRACT.address(chainId);
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvert = reduce.convertTo && !(0, utils_1.isSameAddress)(position.from, reduce.convertTo);
        if (!shouldConvert) {
            // If don't need to convert anything, then just call the hub
            return {
                to: hubAddress,
                data: (0, viem_1.encodeFunctionData)({
                    abi: dca_hub_1.default,
                    functionName: 'reducePosition',
                    args: [BigInt(positionId), BigInt(reduce.amount), amountOfSwaps, recipient],
                }),
            };
        }
        // If we get to this point, then we'll use the Companion for swap & transfer
        const calls = [];
        // Handle permission permit
        if (permissionPermit) {
            calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        // Handle reduce
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'reducePosition',
            args: [hubAddress, BigInt(positionId), BigInt(reduce.amount), amountOfSwaps, config_2.COMPANION_SWAPPER_CONTRACT.address(chainId)],
        }));
        // Handle swap
        const outToken = reduce.convertTo;
        const { swapData } = await this.getSwapData({
            request: {
                chainId,
                sellToken: position.from,
                buyToken: outToken,
                order: { type: 'sell', sellAmount: reduce.amount },
            },
            leftoverRecipient: recipient,
            swapConfig: reduce?.swapConfig,
        });
        calls.push(swapData);
        // Handle transfer
        calls.push(buildSendAllBalance(outToken, recipient));
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls });
    }
    async buildReduceToBuyPositionTx({ chainId, positionId, amountOfSwaps, reduce, recipient, permissionPermit, dcaHub, }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_CONTRACT.address(chainId);
        const calls = [];
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvert = reduce.convertTo && !(0, utils_1.isSameAddress)(position.from, reduce.convertTo);
        if (amountOfSwaps === 0 || !shouldConvert) {
            // In these two scenarios, we can use the normal reduce
            const amount = amountOfSwaps === 0
                ? position.remaining // Withdraw everything
                : reduce.amountToBuy; // Withdraw the specified amount
            return this.buildReducePositionTx({
                chainId,
                positionId,
                amountOfSwaps,
                reduce: { amount, convertTo: reduce.convertTo, swapConfig: reduce.swapConfig },
                recipient,
                permissionPermit,
                dcaHub,
            });
        }
        // Handle permission permit
        if (permissionPermit) {
            calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        // Calculate swap (we know we need to swap if we got to this point)
        const outToken = reduce.convertTo;
        const { bestQuote: buyQuote, swapData } = await this.getSwapData({
            request: {
                chainId,
                sellToken: position.from,
                buyToken: outToken,
                order: { type: 'buy', buyAmount: reduce.amountToBuy },
            },
            leftoverRecipient: recipient,
            swapConfig: reduce?.swapConfig,
        });
        // If we are asking for more than available, then fail
        if (BigInt(buyQuote.maxSellAmount.amount) > position.remaining) {
            throw new Error('Trying to withdraw more than available');
        }
        // Handle reduce
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'reducePosition',
            args: [
                hubAddress,
                BigInt(positionId),
                BigInt(buyQuote.maxSellAmount.amount),
                amountOfSwaps,
                config_2.COMPANION_SWAPPER_CONTRACT.address(chainId),
            ],
        }));
        // Add swap to calls list (needs to go after reduce)
        calls.push(swapData);
        // Handle transfer
        calls.push(buildSendAllBalance(outToken, recipient));
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls });
    }
    async buildWithdrawPositionTx({ chainId, positionId, withdraw, recipient, permissionPermit, dcaHub, }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_CONTRACT.address(chainId);
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvert = withdraw.convertTo && !(0, utils_1.isSameAddress)(position.to, withdraw.convertTo);
        if (!shouldConvert) {
            // If don't need to convert anything, then just call the hub
            return {
                to: hubAddress,
                data: (0, viem_1.encodeFunctionData)({
                    abi: dca_hub_1.default,
                    functionName: 'withdrawSwapped',
                    args: [BigInt(positionId), recipient],
                }),
            };
        }
        // If we get to this point, then we'll use the Companion for swap & transfer
        const calls = [];
        // Handle permission permit
        if (permissionPermit) {
            calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        // Handle withdraw
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'withdrawSwapped',
            args: [hubAddress, BigInt(positionId), config_2.COMPANION_SWAPPER_CONTRACT.address(chainId)],
        }));
        // Handle swap
        const outToken = withdraw.convertTo;
        const { swapData } = await this.getSwapData({
            request: {
                chainId,
                sellToken: position.to,
                buyToken: outToken,
                order: { type: 'sell', sellAmount: position.swapped },
            },
            leftoverRecipient: recipient,
            swapConfig: withdraw?.swapConfig,
        });
        calls.push(swapData);
        // Handle transfer
        calls.push(buildSendAllBalance(outToken, recipient));
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls });
    }
    async buildTerminatePositionTx({ chainId, positionId, withdraw, recipient, permissionPermit, dcaHub, }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_CONTRACT.address(chainId);
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvertUnswapped = position.remaining > 0 && !!withdraw.unswappedConvertTo && !(0, utils_1.isSameAddress)(position.from, withdraw.unswappedConvertTo);
        const shouldConvertSwapped = position.swapped > 0 && !!withdraw.swappedConvertTo && !(0, utils_1.isSameAddress)(position.to, withdraw.swappedConvertTo);
        if (!shouldConvertUnswapped && !shouldConvertSwapped) {
            // If don't need to convert anything, then just call the hub
            return {
                to: hubAddress,
                data: (0, viem_1.encodeFunctionData)({
                    abi: dca_hub_1.default,
                    functionName: 'terminate',
                    args: [BigInt(positionId), recipient, recipient],
                }),
            };
        }
        // If we get to this point, then we'll use the Companion for swap & transfer
        const calls = [];
        // Handle permission permit
        if (permissionPermit) {
            calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        // Handle terminate
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'terminate',
            args: [
                hubAddress,
                BigInt(positionId),
                shouldConvertUnswapped ? config_2.COMPANION_SWAPPER_CONTRACT.address(chainId) : recipient,
                shouldConvertSwapped ? config_2.COMPANION_SWAPPER_CONTRACT.address(chainId) : recipient,
            ],
        }));
        // Handle swaps
        let unswappedPromise, swappedPromise;
        if (shouldConvertUnswapped) {
            const convertTo = withdraw.unswappedConvertTo;
            unswappedPromise = this.getSwapData({
                request: {
                    chainId,
                    sellToken: position.from,
                    buyToken: convertTo,
                    order: { type: 'sell', sellAmount: position.remaining },
                },
                leftoverRecipient: recipient,
                swapConfig: withdraw.swapConfig,
            }).then(({ swapData }) => calls.push(swapData, // Swap
            buildSendAllBalance(convertTo, recipient) // Transfer
            ));
        }
        else {
            unswappedPromise = Promise.resolve();
        }
        if (shouldConvertSwapped) {
            const convertTo = withdraw.swappedConvertTo;
            swappedPromise = this.getSwapData({
                request: {
                    chainId,
                    sellToken: position.to,
                    buyToken: convertTo,
                    order: { type: 'sell', sellAmount: position.swapped },
                },
                leftoverRecipient: recipient,
                swapConfig: withdraw.swapConfig,
            }).then(({ swapData }) => calls.push(swapData, // Swap
            buildSendAllBalance(convertTo, recipient) // Transfer
            ));
        }
        else {
            swappedPromise = Promise.resolve();
        }
        await Promise.all([unswappedPromise, swappedPromise]);
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls });
    }
    async buildMigratePositionTx({ chainId, sourceHub, targetHub, positionId, migration, permissionPermit, }) {
        const bigIntPositionId = BigInt(positionId);
        const [positionOwner, position] = await this.providerService.getViemPublicClient({ chainId }).multicall({
            contracts: [
                { abi: erc721_1.default, address: config_2.DCA_PERMISSION_MANAGER_CONTRACT.address(chainId), functionName: 'ownerOf', args: [bigIntPositionId] },
                { abi: dca_hub_1.default, address: sourceHub, functionName: 'userPosition', args: [bigIntPositionId] },
            ],
            allowFailure: false,
            multicallAddress: utils_2.MULTICALL_CONTRACT.address(chainId),
            batchSize: 0,
        });
        const newFrom = migration.newFrom?.variantId ?? position.from;
        const shouldConvertUnswapped = migration.useFundsFrom !== 'swapped' && position.remaining > 0 && !(0, utils_1.isSameAddress)(position.from, newFrom);
        const shouldConvertSwapped = migration.useFundsFrom !== 'unswapped' && position.swapped > 0 && !(0, utils_1.isSameAddress)(position.to, newFrom);
        const calls = [];
        // Handle permission permit
        if (permissionPermit) {
            calls.push(buildPermissionPermit(permissionPermit, sourceHub));
        }
        // Handle terminate
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'terminate',
            args: [
                sourceHub,
                bigIntPositionId,
                shouldConvertUnswapped
                    ? config_2.COMPANION_SWAPPER_CONTRACT.address(chainId)
                    : migration.useFundsFrom !== 'swapped'
                        ? config_2.COMPANION_CONTRACT.address(chainId)
                        : migration.sendUnusedFundsTo,
                shouldConvertSwapped
                    ? config_2.COMPANION_SWAPPER_CONTRACT.address(chainId)
                    : migration.useFundsFrom !== 'unswapped'
                        ? config_2.COMPANION_CONTRACT.address(chainId)
                        : migration.sendUnusedFundsTo,
            ],
        }));
        // Handle swaps
        let unswappedPromise, swappedPromise;
        if (shouldConvertUnswapped) {
            unswappedPromise = this.getSwapData({
                request: {
                    chainId,
                    sellToken: position.from,
                    buyToken: newFrom,
                    order: { type: 'sell', sellAmount: position.remaining },
                },
                leftoverRecipient: positionOwner,
                swapConfig: migration?.swapConfig,
            }).then(({ swapData }) => calls.push(swapData));
        }
        else {
            unswappedPromise = Promise.resolve();
        }
        if (shouldConvertSwapped) {
            swappedPromise = this.getSwapData({
                request: {
                    chainId,
                    sellToken: position.to,
                    buyToken: newFrom,
                    order: { type: 'sell', sellAmount: position.swapped },
                },
                leftoverRecipient: positionOwner,
                swapConfig: migration?.swapConfig,
            }).then(({ swapData }) => calls.push(swapData));
        }
        else {
            swappedPromise = Promise.resolve();
        }
        await Promise.all([unswappedPromise, swappedPromise]);
        // Handle re-deposit
        calls.push((0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'depositWithBalanceOnContract',
            args: [
                targetHub,
                newFrom,
                (migration.newTo?.variantId ?? position.to),
                position.swapsLeft,
                position.swapInterval,
                positionOwner,
                [],
                '0x',
            ],
        }));
        // Build multicall and return tx
        return buildCompanionMulticall({ chainId, calls });
    }
    async getSupportedPairs(args) {
        const params = qs_1.default.stringify({ chains: args?.chains }, { arrayFormat: 'comma', skipNulls: true });
        const url = `${this.apiUrl}/v2/dca/pairs/supported?${params}`;
        const response = await this.fetchService.fetch(url, { timeout: args?.config?.timeout });
        const body = await response.json();
        const result = {};
        for (const chainId in body.pairsByNetwork) {
            const { pairs, tokens } = body.pairsByNetwork[chainId];
            result[Number(chainId)] = {
                pairs: pairs.map((pair) => buildPair(Number(chainId), pair, tokens)),
                tokens,
            };
        }
        return result;
    }
    async getPositionsByAccount({ accounts, chains, includeHistory, config, }) {
        const params = qs_1.default.stringify({ users: accounts, chains, includeHistory }, { arrayFormat: 'comma', skipNulls: true });
        return this.fetchPositions(params, config?.timeout);
    }
    async getPositionsById({ ids, includeHistory, config, }) {
        const encodedIds = ids.map(({ chainId, hub, positionId }) => `${chainId}-${hub}-${positionId}`);
        const params = qs_1.default.stringify({ ids: encodedIds, includeHistory }, { arrayFormat: 'comma', skipNulls: true });
        return this.fetchPositions(params, config?.timeout);
    }
    async getPairSwaps({ chainId, variantTokenA, variantTokenB, config, }) {
        const url = `${this.apiUrl}/v2/dca/pairs/${chainId}-${variantTokenA}-${variantTokenB}/swaps`;
        const response = await this.fetchService.fetch(url, { timeout: config?.timeout });
        const { tokenA, tokenB, swaps } = await response.json();
        return {
            tokenA,
            tokenB,
            swaps: swaps.map((swap) => ({
                ...swap,
                ratioAToB: toBigInt(swap.ratioAToB),
                ratioBToA: toBigInt(swap.ratioBToA),
                ratioAToBWithFee: toBigInt(swap.ratioAToBWithFee),
                ratioBToAWithFee: toBigInt(swap.ratioBToAWithFee),
                intervalsInSwap: swap.intervalsInSwap.map(({ seconds }) => seconds),
            })),
        };
    }
    async fetchPositions(params, timeout) {
        const url = `${this.apiUrl}/v2/dca/positions?${params}`;
        const response = await this.fetchService.fetch(url, { timeout });
        const body = await response.json();
        const tokensToFetch = calculateMissingPrices(body);
        const prices = tokensToFetch.length === 0 ? {} : await this.priceService.getBulkHistoricalPrices({ tokens: tokensToFetch, config: { timeout: timeout } });
        const result = {};
        for (const chainId in body.positionsByNetwork) {
            const { positions, tokens } = body.positionsByNetwork[chainId];
            result[Number(chainId)] = positions.map((position) => buildPosition(position, tokens, prices[Number(chainId)] ?? {}));
        }
        return result;
    }
    async getSwapData({ request, leftoverRecipient, swapConfig, }) {
        const txValidFor = swapConfig?.txValidFor ?? '1w';
        const bestQuote = await this.quoteService.getBestQuote({
            request: {
                ...request,
                slippagePercentage: swapConfig?.slippagePercentage ?? 0.3,
                takerAddress: config_2.COMPANION_SWAPPER_CONTRACT.address(request.chainId),
                recipient: config_2.COMPANION_SWAPPER_CONTRACT.address(request.chainId),
                txValidFor,
                filters: { includeSources: ['balmy'] }, // TODO: allow more sources and simulate to find the best one
                sourceConfig: { custom: { balmy: { leftoverRecipient } } },
            },
            config: {
                timeout: '5s',
            },
        });
        const { [bestQuote.source.id]: tx } = await this.quoteService.buildAllTxs({
            config: { timeout: '5s' },
            quotes: { [bestQuote.source.id]: bestQuote },
            sourceConfig: { custom: { balmy: { leftoverRecipient } } },
        });
        const allowanceTargets = (0, utils_1.isSameAddress)(bestQuote.source.allowanceTarget, constants_1.Addresses.ZERO_ADDRESS)
            ? []
            : [{ token: bestQuote.sellToken.address, target: bestQuote.source.allowanceTarget }];
        // Swap adapter uses the zero address as the native token
        const tokenOutDistribution = (0, utils_1.isSameAddress)(bestQuote.buyToken.address, constants_1.Addresses.NATIVE_TOKEN)
            ? constants_1.Addresses.ZERO_ADDRESS
            : bestQuote.buyToken.address;
        const arbitraryCall = this.permit2Service.arbitrary.buildArbitraryCallWithoutPermit({
            allowanceTargets,
            calls: [{ to: tx.to, data: tx.data, value: tx.value ?? 0n }],
            distribution: { [tokenOutDistribution]: [{ recipient: config_2.COMPANION_CONTRACT.address(request.chainId), shareBps: 0 }] },
            txValidFor,
            chainId: request.chainId,
        });
        const swapData = (0, viem_1.encodeFunctionData)({
            abi: companion_1.default,
            functionName: 'runSwap',
            args: [
                constants_1.Addresses.ZERO_ADDRESS, // No need to set it because we are already transferring the funds to the swapper
                tx.value ?? 0n,
                arbitraryCall.data,
                bestQuote.buyToken.address,
            ],
        });
        return { bestQuote, swapData };
    }
    async getUserPosition(chainId, hubAddress, positionId) {
        const [position] = await this.providerService.getViemPublicClient({ chainId }).multicall({
            contracts: [{ abi: dca_hub_1.default, address: hubAddress, functionName: 'userPosition', args: [BigInt(positionId)] }],
            allowFailure: false,
            multicallAddress: utils_2.MULTICALL_CONTRACT.address(chainId),
            batchSize: 0,
        });
        return { ...position, remaining: BigInt(position.remaining), swapped: BigInt(position.swapped) };
    }
}
exports.DCAService = DCAService;
function buildTakeFromCallerWithPermit({ token, amount, nonce, deadline }, signature, recipient) {
    return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: 'permitTakeFromCaller',
        args: [token, BigInt(amount), BigInt(nonce), BigInt(deadline), signature, recipient],
    });
}
function buildTakeFromCaller(token, amount, recipient) {
    return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: 'takeFromCaller',
        args: [token, BigInt(amount), recipient],
    });
}
function buildPermissionPermit(permit, hub) {
    const permissionManager = PERMISSION_MANAGER_FOR_HUB[hub.toLowerCase()];
    return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: 'permissionPermit',
        args: [
            permissionManager,
            permit.permissions.map(({ operator, permissions }) => ({
                operator: operator,
                permissions: permissions.map(mapPermission),
            })),
            BigInt(permit.tokenId),
            BigInt(permit.deadline),
            parseInt(permit.v.toString()),
            permit.r,
            permit.s,
        ],
    });
}
function mapPermission(permission) {
    switch (permission) {
        case types_1.DCAPermission.INCREASE:
            return 0;
        case types_1.DCAPermission.REDUCE:
            return 1;
        case types_1.DCAPermission.WITHDRAW:
            return 2;
        case types_1.DCAPermission.TERMINATE:
            return 3;
    }
}
function buildSendAllBalance(token, recipient) {
    return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: 'sendBalanceOnContractToRecipient',
        args: [token, recipient],
    });
}
async function buildCompanionMulticall({ chainId, calls, value }) {
    const data = (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: 'multicall',
        args: [calls],
    });
    return { to: config_2.COMPANION_CONTRACT.address(chainId), data, value };
}
function buildPair(chainId, pair, tokens) {
    const tokenA = tokens[pair.tokenA];
    const tokenB = tokens[pair.tokenB];
    return {
        chainId: Number(chainId),
        ...pair,
        swapIntervals: buildSwapIntervals(pair.swapIntervals, tokenA, tokenB),
    };
}
function buildSwapIntervals(swapIntervals, tokenA, tokenB) {
    const tokenAVariantIds = tokenA.variants.map(({ id }) => id);
    const tokenBVariantIds = tokenB.variants.map(({ id }) => id);
    const variantCombinations = tokenAVariantIds.flatMap((tokenAVariantId) => tokenBVariantIds.map((tokenBVariantId) => `${tokenAVariantId}-${tokenBVariantId}`));
    const result = {};
    const allIntervals = Object.keys(types_1.DCASwapInterval).slice(0, 8);
    for (const seconds of allIntervals) {
        const intervalName = types_1.DCASwapInterval[Number(seconds)];
        const nextSwapAvailableAt = {};
        const isStale = {};
        for (const combination of variantCombinations) {
            isStale[combination] = swapIntervals[intervalName]?.stale?.includes(combination) ?? false;
            nextSwapAvailableAt[combination] = swapIntervals[intervalName]?.nextSwapBlockedUntil[combination] ?? 0;
        }
        result[intervalName] = { seconds: Number(seconds), nextSwapAvailableAt, isStale };
    }
    return result;
}
function buildPosition(position, tokens, prices) {
    const { variants: fromVariants, ...fromToken } = tokens[position.from.address];
    const { variants: toVariants, ...toToken } = tokens[position.to.address];
    const fromVariant = fromVariants.find(({ id }) => id == position.from.variant.id) ?? position.from.variant;
    const toVariant = toVariants.find(({ id }) => id === position.to.variant.id) ?? position.to.variant;
    const [chainId, hub, tokenId] = position.id.split('-');
    return {
        chainId: Number(chainId),
        hub,
        pair: {
            pairId: toPairId(position.from.address, position.to.address),
            variantPairId: toPairId(position.from.variant.id, position.to.variant.id),
        },
        tokenId: BigInt(tokenId),
        ...position,
        from: {
            ...position.from,
            ...fromToken,
            variant: fromVariant,
        },
        to: {
            ...position.to,
            ...toToken,
            variant: toVariant,
        },
        swapInterval: position.swapInterval.seconds,
        rate: (0, utils_1.toAmountsOfToken)({ ...fromToken, amount: position.rate }),
        funds: {
            swapped: (0, utils_1.toAmountsOfToken)({ ...toToken, amount: position.funds.swapped }),
            remaining: (0, utils_1.toAmountsOfToken)({ ...fromToken, amount: position.funds.remaining }),
            toWithdraw: (0, utils_1.toAmountsOfToken)({ ...toToken, amount: position.funds.toWithdraw }),
        },
        generatedByYield: position.yield
            ? {
                swapped: position.yield.swapped === undefined ? undefined : (0, utils_1.toAmountsOfToken)({ ...toToken, amount: position.yield.swapped }),
                remaining: position.yield.remaining === undefined ? undefined : (0, utils_1.toAmountsOfToken)({ ...fromToken, amount: position.yield.remaining }),
                toWithdraw: position.yield.toWithdraw === undefined ? undefined : (0, utils_1.toAmountsOfToken)({ ...toToken, amount: position.yield.toWithdraw }),
            }
            : undefined,
        history: position.history?.map((action) => mapAction(action, position, prices)) ?? [],
    };
}
function toPairId(address1, address2) {
    const lower1 = address1.toLowerCase();
    const lower2 = address2.toLowerCase();
    const [tokenA, tokenB] = lower1 < lower2 ? [lower1, lower2] : [lower2, lower1];
    return `${tokenA}-${tokenB}`;
}
function mapAction(action, position, prices) {
    switch (action.action) {
        case types_1.ActionTypeAction.CREATED:
            return {
                ...action,
                fromPrice: action.fromPrice ?? prices[position.from.address]?.[action.tx.timestamp]?.price,
                rate: toBigInt(action.rate),
                tx: mapActionTx(action.tx),
            };
        case types_1.ActionTypeAction.MODIFIED:
            return {
                ...action,
                fromPrice: action.fromPrice ?? prices[position.from.address]?.[action.tx.timestamp]?.price,
                rate: toBigInt(action.rate),
                oldRate: toBigInt(action.oldRate),
                tx: mapActionTx(action.tx),
            };
        case types_1.ActionTypeAction.WITHDRAWN:
            return {
                ...action,
                toPrice: action.toPrice ?? prices[position.to.address]?.[action.tx.timestamp]?.price,
                withdrawn: toBigInt(action.withdrawn),
                generatedByYield: action.yield && { withdrawn: toBigInt(action.yield.withdrawn) },
                tx: mapActionTx(action.tx),
            };
        case types_1.ActionTypeAction.TERMINATED:
            return {
                ...action,
                fromPrice: action.fromPrice ?? prices[position.from.address]?.[action.tx.timestamp]?.price,
                toPrice: action.toPrice ?? prices[position.to.address]?.[action.tx.timestamp]?.price,
                withdrawnRemaining: toBigInt(action.withdrawnRemaining),
                withdrawnSwapped: toBigInt(action.withdrawnSwapped),
                generatedByYield: action.yield && {
                    withdrawnRemaining: toBigInt(action.yield.withdrawnRemaining),
                    withdrawnSwapped: toBigInt(action.yield.withdrawnSwapped),
                },
                tx: mapActionTx(action.tx),
            };
        case types_1.ActionTypeAction.SWAPPED:
            return {
                ...action,
                tokenA: {
                    address: action.tokenA.address,
                    price: action.tokenA.price ?? prices[action.tokenA.address]?.[action.tx.timestamp]?.price,
                },
                tokenB: {
                    address: action.tokenB.address,
                    price: action.tokenB.price ?? prices[action.tokenB.address]?.[action.tx.timestamp]?.price,
                },
                rate: toBigInt(action.rate),
                swapped: toBigInt(action.swapped),
                ratioAToB: toBigInt(action.ratioAToB),
                ratioBToA: toBigInt(action.ratioBToA),
                ratioAToBWithFee: toBigInt(action.ratioAToBWithFee),
                ratioBToAWithFee: toBigInt(action.ratioBToAWithFee),
                generatedByYield: action.yield && { rate: toBigInt(action.yield.rate) },
                tx: mapActionTx(action.tx),
            };
        case types_1.ActionTypeAction.TRANSFERRED:
        case types_1.ActionTypeAction.MODIFIED_PERMISSIONS:
            return { ...action, tx: mapActionTx(action.tx) };
    }
}
function mapActionTx(tx) {
    return {
        ...tx,
        gasPrice: toBigInt(tx.gasPrice),
        l1GasPrice: toBigInt(tx.l1GasPrice),
        overhead: toBigInt(tx.overhead),
    };
}
function calculateMissingPrices(response) {
    const toFetch = [];
    for (const chainIdString in response.positionsByNetwork) {
        const chainId = Number(chainIdString);
        for (const position of response.positionsByNetwork[chainId].positions) {
            for (const action of position.history ?? []) {
                switch (action.action) {
                    case types_1.ActionTypeAction.CREATED:
                    case types_1.ActionTypeAction.MODIFIED:
                        if (!action.fromPrice) {
                            toFetch.push({ chainId, token: position.from.address, timestamp: action.tx.timestamp });
                        }
                        break;
                    case types_1.ActionTypeAction.WITHDRAWN:
                        if (!action.toPrice) {
                            toFetch.push({ chainId, token: position.to.address, timestamp: action.tx.timestamp });
                        }
                        break;
                    case types_1.ActionTypeAction.TERMINATED:
                        if (!action.fromPrice) {
                            toFetch.push({ chainId, token: position.from.address, timestamp: action.tx.timestamp });
                        }
                        if (!action.toPrice) {
                            toFetch.push({ chainId, token: position.to.address, timestamp: action.tx.timestamp });
                        }
                        break;
                    case types_1.ActionTypeAction.SWAPPED: {
                        if (!action.tokenA.price) {
                            toFetch.push({ chainId, token: action.tokenA.address, timestamp: action.tx.timestamp });
                        }
                        if (!action.tokenB.price) {
                            toFetch.push({ chainId, token: action.tokenB.address, timestamp: action.tx.timestamp });
                        }
                    }
                }
            }
        }
    }
    return toFetch;
}
function toBigInt(text) {
    return (text === undefined ? undefined : BigInt(text));
}
const PERMISSION_MANAGER_FOR_HUB = {
    // Yield
    '0xa5adc5484f9997fbf7d405b9aa62a7d88883c345': '0x20bdAE1413659f47416f769a4B27044946bc9923',
    // Stable
    '0x059d306a25c4ce8d7437d25743a8b94520536bd5': '0x6f54391fe0386d506b51d69deeb8b04e0544e088',
    // Vuln
    '0x230c63702d1b5034461ab2ca889a30e343d81349': '0xb4edfb45446c6a207643ea846bfa42021ce5ae11',
    // Beta
    '0x24f85583faa9f8bd0b8aa7b1d1f4f53f0f450038': '0x09AdE44D2E60fCa2270fF32Af5a189f40D29837b',
    // Yield (RSK)
    [config_2.DCA_HUB_CONTRACT.address(_chains_1.Chains.ROOTSTOCK.chainId)]: config_2.DCA_PERMISSION_MANAGER_CONTRACT.address(_chains_1.Chains.ROOTSTOCK.chainId),
};
//# sourceMappingURL=dca-service.js.map