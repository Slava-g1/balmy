"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicRPCsProviderSource = void 0;
const _chains_1 = require("../../../chains");
const http_provider_1 = require("./http-provider");
const load_balance_provider_1 = require("./load-balance-provider");
const fallback_provider_1 = require("./fallback-provider");
class PublicRPCsProviderSource {
    constructor(params) {
        const sources = buildSources(calculateRPCs(params?.publicRPCs));
        this.source =
            params?.config?.type === 'fallback'
                ? new fallback_provider_1.FallbackProviderSource(sources, params.config)
                : new load_balance_provider_1.LoadBalanceProviderSource(sources, params?.config);
    }
    supportedChains() {
        return this.source.supportedChains();
    }
    getViemTransport({ chainId }) {
        return this.source.getViemTransport({ chainId });
    }
}
exports.PublicRPCsProviderSource = PublicRPCsProviderSource;
function buildSources(publicRPCs) {
    return publicRPCs.map(({ chainId, publicRPC }) => new http_provider_1.HttpProviderSource(publicRPC, [chainId]));
}
function calculateRPCs(publicRPCs) {
    const rpcsByChain = publicRPCs
        ? Object.entries(publicRPCs).map(([chainId, rpcs]) => [Number(chainId), rpcs])
        : (0, _chains_1.getAllChains)()
            .filter((chain) => chain.publicRPCs.length > 0)
            .map(({ chainId, publicRPCs }) => [chainId, publicRPCs]);
    return rpcsByChain.flatMap(([chainId, publicRPCs]) => publicRPCs.map((publicRPC) => ({ publicRPC, chainId: Number(chainId) })));
}
//# sourceMappingURL=public-rpcs-provider.js.map