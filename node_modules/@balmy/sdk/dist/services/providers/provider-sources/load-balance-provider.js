"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadBalanceProviderSource = void 0;
const _chains_1 = require("../../../chains");
const viem_1 = require("viem");
const ms_1 = __importDefault(require("ms"));
const timeouts_1 = require("../../../shared/timeouts");
class LoadBalanceProviderSource {
    constructor(sources, config) {
        this.sources = sources;
        this.config = config;
        if (sources.length === 0)
            throw new Error('Need at least one source to setup the provider source');
    }
    supportedChains() {
        return (0, _chains_1.chainsUnion)(this.sources.map((source) => source.supportedChains()));
    }
    getViemTransport({ chainId }) {
        const transports = this.sources
            .filter((source) => source.supportedChains().includes(chainId))
            .map((source) => source.getViemTransport({ chainId }));
        if (transports.length === 0)
            throw new Error(`Chain with id ${chainId} not supported`);
        return loadBalance(transports, this.config);
    }
}
exports.LoadBalanceProviderSource = LoadBalanceProviderSource;
const DEFAULT_CONFIG = {
    minSuccessRate: 0.05,
    minSamples: 3,
    samplesTtl: '30m',
    maxConcurrent: 2,
};
function loadBalance(transports_, config = {}) {
    const { minSuccessRate, minSamples, maxAttempts, maxConcurrent, samplesTtl, timeout } = { ...DEFAULT_CONFIG, ...config };
    return ({ chain, timeout: transportTimeout, ...rest }) => {
        const defaultTimeout = timeout?.default ? (0, ms_1.default)(timeout.default) : transportTimeout;
        const timeoutsByMethod = timeout?.byMethod
            ? Object.fromEntries(Object.entries(timeout.byMethod).map(([method, timeout]) => [method, (0, ms_1.default)(timeout)]))
            : {};
        const transports = transports_
            .map((t) => t({ chain, timeout: defaultTimeout, ...rest }))
            .map((transport) => new TransportInstance(transport, { samplesTtl }));
        const request = async ({ method, ...params }) => {
            const availableTransports = Object.fromEntries(transports.map((transport, index) => [`${index}`, transport]));
            const errors = [];
            let attempts = 0;
            while (!maxAttempts || attempts < maxAttempts) {
                const filteredTransports = Object.entries(availableTransports)
                    .map(([id, transport]) => ({ transport, id, metrics: transport.metrics(method) }))
                    .filter(({ metrics }) => metrics.samples.length < minSamples || calculateSuccessRate(metrics) > minSuccessRate);
                if (filteredTransports.length === 0) {
                    break; // No transports available
                }
                let toExecute;
                const transportsWithSamples = filteredTransports.filter(({ metrics }) => metrics.samples.length > 0);
                const transportsWithoutSamples = filteredTransports.filter(({ metrics }) => metrics.samples.length === 0);
                if (transportsWithSamples.length > 0) {
                    // If there are some transports with samples, then find the best among them
                    const bestTransport = transportsWithSamples.reduce((best, current) => calculateScore(current.metrics) > calculateScore(best.metrics) ? current : best);
                    // We will execute the best transport together with all transports that have no samples. We do this because we don't know if those transports are good or bad
                    // and we will take this opportunity to gather some samples from them
                    toExecute = [bestTransport, ...transportsWithoutSamples];
                }
                else {
                    // If there are no transports with samples, then we will execute all transports. We will return one that succeeds first and add some samples for the others at the same time
                    toExecute = transportsWithoutSamples;
                }
                if (maxAttempts || maxConcurrent > 0) {
                    // If we have a limit on the number of attempts, we will execute only the number of transports that we can afford
                    const attemptsLeft = maxAttempts ? maxAttempts - attempts : Infinity;
                    toExecute = toExecute.slice(0, Math.min(attemptsLeft, maxConcurrent));
                }
                try {
                    return await Promise.any(toExecute.map(({ transport }) => transport.request({ method, ...params })));
                }
                catch (error) {
                    // Consider all transports used as attempts
                    attempts += toExecute.length;
                    // Remove executed transports from the list of available transports
                    toExecute.forEach(({ id }) => delete availableTransports[id]);
                    // Remember error
                    if (error instanceof AggregateError) {
                        errors.push(...error.errors);
                    }
                    else {
                        errors.push(error);
                    }
                }
            }
            throw errors.length > 0 ? new AggregateError(errors) : new Error('Failed to find a transport to execute the request'); // No transports available
        };
        return (0, viem_1.createTransport)({
            key: 'load-balance',
            name: 'Load Balancing',
            type: 'load-balance',
            async request({ method, ...params }) {
                const timeout = timeoutsByMethod[method] ?? defaultTimeout;
                return (0, timeouts_1.timeoutPromise)(request({ method, ...params }), timeout);
            },
        });
    };
}
class TransportInstance {
    constructor(transport, config) {
        this.transport = transport;
        this.config = config;
        this.methodMetrics = {};
    }
    async request(...args) {
        const start = Date.now();
        const method = args[0].method;
        this.initializeMetricsIfNecessary(method);
        this.methodMetrics[method].pending++;
        try {
            const result = await this.transport.request(...args);
            this.addSample({ method, start, success: true });
            return result;
        }
        catch (e) {
            this.addSample({ method, start, success: false });
            throw e;
        }
    }
    metrics(method) {
        this.initializeMetricsIfNecessary(method);
        // Cleanup
        const cutoffTime = Date.now() - (0, ms_1.default)(this.config.samplesTtl);
        const validSampleIndex = this.methodMetrics[method].samples.findIndex(({ timestamp }) => timestamp >= cutoffTime);
        if (validSampleIndex === -1) {
            this.methodMetrics[method].samples.length = 0;
        }
        else if (validSampleIndex > 0) {
            this.methodMetrics[method].samples = this.methodMetrics[method].samples.slice(validSampleIndex);
        }
        return this.methodMetrics[method];
    }
    initializeMetricsIfNecessary(method) {
        if (!(method in this.methodMetrics)) {
            this.methodMetrics[method] = { pending: 0, samples: [] };
        }
    }
    addSample({ method, start, success }) {
        const processingTime = Date.now() - start;
        const sample = { timestamp: Date.now(), success, processingTime };
        this.methodMetrics[method].samples.push(sample);
        this.methodMetrics[method].pending--;
    }
}
function calculateSuccessRate(metrics) {
    return metrics && metrics.samples ? metrics.samples.reduce((acc, sample) => acc + (sample.success ? 1 : 0), 0) / metrics.samples.length : 0;
}
function calculateScore(metrics) {
    if (metrics.samples.length == 0)
        return Infinity;
    const avgProcessingTime = metrics.samples.reduce((acc, sample) => acc + sample.processingTime, 0) / metrics.samples.length;
    const successRate = calculateSuccessRate(metrics);
    return successRate * 0.7 + (1 - avgProcessingTime / 1000) * 0.3;
}
//# sourceMappingURL=load-balance-provider.js.map