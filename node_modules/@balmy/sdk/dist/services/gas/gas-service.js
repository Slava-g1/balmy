"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasService = void 0;
const _chains_1 = require("../../chains");
const timeouts_1 = require("../../shared/timeouts");
const requirements_and_support_1 = require("../../shared/requirements-and-support");
const viem_1 = require("../../shared/viem");
class GasService {
    constructor({ providerService, gasPriceSource }) {
        this.providerService = providerService;
        this.gasPriceSource = gasPriceSource;
    }
    supportedChains() {
        return (0, _chains_1.chainsIntersection)(this.providerService.supportedChains(), Object.keys(this.gasPriceSource.supportedSpeeds()).map(Number));
    }
    supportedSpeeds() {
        const supportedChains = this.supportedChains();
        const entries = Object.entries(this.gasPriceSource.supportedSpeeds()).filter(([chainId]) => supportedChains.includes(Number(chainId)));
        return Object.fromEntries(entries);
    }
    estimateGas({ chainId, tx, config }) {
        const promise = this.estimateGasInternal(chainId, tx);
        return (0, timeouts_1.timeoutPromise)(promise, config?.timeout);
    }
    async getQuickGasCalculator({ chainId, config, }) {
        (0, requirements_and_support_1.validateRequirements)(this.supportedSpeeds(), [chainId], config?.fields);
        const support = this.supportedSpeeds()[chainId];
        const gasPriceData = await (0, timeouts_1.timeoutPromise)(this.gasPriceSource.getGasPrice({ chainId, config }), config?.timeout);
        if (!(0, requirements_and_support_1.doesResponseMeetRequirements)(gasPriceData, config?.fields)) {
            throw new Error('Failed to fetch gas prices that meet the given requirements');
        }
        return {
            supportedSpeeds: () => support,
            getGasPrice: () => gasPriceData,
            calculateGasCost: ({ gasEstimation }) => {
                const result = {};
                for (const [speed, gasPriceForSpeed] of Object.entries(gasPriceData)) {
                    const actualGasPrice = 'maxFeePerGas' in gasPriceForSpeed ? gasPriceForSpeed.maxFeePerGas : gasPriceForSpeed.gasPrice;
                    const gasCostNativeToken = (BigInt(gasEstimation) * BigInt(actualGasPrice)).toString();
                    result[speed] = { gasCostNativeToken, ...gasPriceForSpeed };
                }
                return result;
            },
        };
    }
    async getGasPrice({ chainId, config, }) {
        const gasCalculator = await this.getQuickGasCalculator({ chainId, config });
        return gasCalculator.getGasPrice();
    }
    async calculateGasCost({ chainId, gasEstimation, tx, config, }) {
        const gasCalculator = await this.getQuickGasCalculator({ chainId, config });
        return gasCalculator.calculateGasCost({ gasEstimation, tx });
    }
    async estimateGasInternal(chainId, tx) {
        const viemTx = (0, viem_1.mapTxToViemTx)(tx);
        const client = this.providerService.getViemPublicClient({ chainId });
        const estimateGasPromise = client.estimateGas(viemTx);
        // Note: in most chains, calling `estimateGas` would reject if the transaction were to revert. However, in RSK
        //       it doesn't work that way. In order to be consistent, when we are estimating gas for RSK, we also simulate
        //       the transaction using `call` to make sure it doesn't revert.
        const callPromise = chainId === _chains_1.Chains.ROOTSTOCK.chainId ? client.call(viemTx) : Promise.resolve();
        const [estimatedGas] = await Promise.all([estimateGasPromise, callPromise]);
        return estimatedGas;
    }
}
exports.GasService = GasService;
//# sourceMappingURL=gas-service.js.map