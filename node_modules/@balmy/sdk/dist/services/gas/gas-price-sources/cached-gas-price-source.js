"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedGasPriceSource = void 0;
const concurrent_lru_cache_1 = require("../../../shared/concurrent-lru-cache");
const requirements_and_support_1 = require("../../../shared/requirements-and-support");
class CachedGasPriceSource {
    constructor({ underlying, expiration, maxSize }) {
        this.underlying = underlying;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCacheWithContext({
            calculate: (config, [cacheId]) => this.fromCacheKey(cacheId, config), // We know that we will only ask for one chain at a time
            config: {
                expiration: expiration.default,
                maxSize: maxSize ?? Object.keys(underlying.supportedSpeeds()).length,
            },
        });
        this.expirationOverrides = expiration.overrides ?? {};
    }
    supportedSpeeds() {
        return this.underlying.supportedSpeeds();
    }
    async getGasPrice({ chainId, config, }) {
        const expirationConfig = this.expirationOverrides[chainId];
        const key = this.toCacheKey(chainId, config?.fields);
        const gasPrice = await this.cache.getOrCalculateSingle({
            key,
            context: config,
            expirationConfig,
            timeout: config?.timeout,
        });
        return gasPrice;
    }
    toCacheKey(chainId, requirements) {
        const support = this.underlying.supportedSpeeds()[chainId];
        const fieldRequirements = (0, requirements_and_support_1.calculateFieldRequirements)(support, requirements);
        const requiredFields = Object.entries(fieldRequirements)
            .filter(([, requirement]) => requirement === 'required')
            .map(([field]) => field)
            .sort()
            .join(',');
        return `${chainId}-${requiredFields}`;
    }
    async fromCacheKey(cacheId, config) {
        const [chainIdString, requiredFieldsText] = cacheId.split('-');
        const requiredFields = requiredFieldsText.length > 0 ? requiredFieldsText.split(',') : [];
        const requirements = Object.fromEntries(requiredFields.map((field) => [field, 'required']));
        // We set the default to best effort here, even if it wasn't set on the original request. The idea is that we try our best to fetch all properties,
        // so that if we have a future request with the same required fields and best effort is set, then we can use the cached values
        const gasPrice = await this.underlying.getGasPrice({
            chainId: Number(chainIdString),
            config: { ...config, fields: { requirements, default: 'best effort' } },
        });
        return { [cacheId]: gasPrice };
    }
}
exports.CachedGasPriceSource = CachedGasPriceSource;
//# sourceMappingURL=cached-gas-price-source.js.map