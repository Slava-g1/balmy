"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatorGasPriceSource = void 0;
const requirements_and_support_1 = require("../../../shared/requirements-and-support");
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("../../../shared/utils");
const utils_2 = require("../utils");
class AggregatorGasPriceSource {
    constructor(logsService, sources, method) {
        this.sources = sources;
        this.method = method;
        this.logger = logsService.getLogger({ name: 'AggregatorGasPriceSource' });
        if (sources.length === 0)
            throw new Error('No sources were specified');
    }
    supportedSpeeds() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedSpeeds());
    }
    async getGasPrice({ chainId, config, }) {
        const sourcesInChain = this.sources.filter((source) => chainId in source.supportedSpeeds() && (0, requirements_and_support_1.couldSupportMeetRequirements)(source.supportedSpeeds()[chainId], config?.fields));
        if (sourcesInChain.length === 0)
            throw new Error(`Chain with id ${chainId} cannot support the given requirements`);
        const promises = sourcesInChain.map((source) => (0, timeouts_1.timeoutPromise)(source.getGasPrice({ chainId, config }), config?.timeout, { reduceBy: '100' }));
        const results = await (0, utils_1.filterRejectedResults)(promises);
        if (results.length === 0) {
            for (const promise of promises) {
                await promise.catch((e) => this.logger.debug(`Gas price source failed with '${e}'`));
            }
            throw new Error('Failed to calculate gas on all sources');
        }
        const validResults = results.filter(utils_2.filterOutInvalidSpeeds).filter((response) => (0, requirements_and_support_1.doesResponseMeetRequirements)(response, config?.fields));
        if (validResults.length === 0)
            throw new Error('Could not fetch gas prices that met the given requirements');
        const resultsToAggregate = resultsWithMaxSpeed(validResults);
        const result = this.aggregate(resultsToAggregate);
        return result;
    }
    aggregate(results) {
        const is1559 = results.some(utils_2.isEIP1159Compatible);
        if (is1559) {
            const collected = collectBySpeed(results.filter(utils_2.isEIP1159Compatible));
            return aggregate(true, collected, this.method);
        }
        else {
            const collected = collectBySpeed(results.filter((result) => !(0, utils_2.isEIP1159Compatible)(result)));
            return aggregate(false, collected, this.method);
        }
    }
}
exports.AggregatorGasPriceSource = AggregatorGasPriceSource;
function resultsWithMaxSpeed(results) {
    const maxSpeeds = results.reduce((accum, curr) => (Object.keys(accum).length >= Object.keys(curr).length ? accum : curr));
    const speedsId = (result) => Object.keys(result).join('-');
    const maxSpeedsId = speedsId(maxSpeeds);
    return results.filter((result) => maxSpeedsId === speedsId(result));
}
function collectBySpeed(array) {
    const collected = {};
    for (const gasPrice of array) {
        for (const speed in gasPrice) {
            if (!(speed in collected))
                collected[speed] = [];
            collected[speed].push(gasPrice[speed]);
        }
    }
    return collected;
}
function aggregate(is1559, bySpeed, method) {
    const result = {};
    for (const speed in bySpeed) {
        result[speed] = aggregateBySpeed(is1559, bySpeed[speed], method);
    }
    return result;
}
function aggregateBySpeed(is1559, toAggregate, method) {
    return is1559 ? aggregate1559(toAggregate, method) : aggregateLegacy(toAggregate, method);
}
function aggregate1559(toAggregate, method) {
    switch (method) {
        case 'median':
            return medianByProperty(toAggregate, 'maxFeePerGas');
        case 'max':
            return maxByProperty(toAggregate, 'maxFeePerGas');
        case 'min':
            return minByProperty(toAggregate, 'maxFeePerGas');
    }
}
function aggregateLegacy(toAggregate, method) {
    switch (method) {
        case 'median':
            return medianByProperty(toAggregate, 'gasPrice');
        case 'max':
            return maxByProperty(toAggregate, 'gasPrice');
        case 'min':
            return minByProperty(toAggregate, 'gasPrice');
    }
}
function medianByProperty(array, property) {
    const sorted = array.sort((a, b) => (BigInt(a[property]) <= BigInt(b[property]) ? -1 : 1));
    return sorted[Math.floor(Math.max(sorted.length - 1, 0) / 2)];
}
function maxByProperty(array, property) {
    return array.reduce((accum, curr) => (BigInt(accum[property]) >= BigInt(curr[property]) ? accum : curr));
}
function minByProperty(array, property) {
    return array.reduce((accum, curr) => (BigInt(accum[property]) <= BigInt(curr[property]) ? accum : curr));
}
//# sourceMappingURL=aggregator-gas-price-source.js.map