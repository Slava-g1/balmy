"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCGasPriceSource = void 0;
const timeouts_1 = require("../../../shared/timeouts");
class RPCGasPriceSource {
    constructor(providerService) {
        this.providerService = providerService;
    }
    supportedSpeeds() {
        const support = { standard: 'present' };
        return Object.fromEntries(this.providerService.supportedChains().map((chainId) => [Number(chainId), support]));
    }
    getGasPrice({ chainId, config }) {
        const client = this.providerService.getViemPublicClient({ chainId });
        const promise = calculatePrice(client);
        return (0, timeouts_1.timeoutPromise)(promise, config?.timeout);
    }
}
exports.RPCGasPriceSource = RPCGasPriceSource;
async function calculatePrice(client) {
    // We need to specify a type, or viem will default to eip1559 and fail if the chain doesn't support it. So we've looked into what viem does
    // and we realized that it will fetch a block, and then return the latest price. So we fetch it first to determine the time, and then pass
    // it to viem, even though it doesn't accept it "publicly". But it does use it nevertheless and it doesn't fetch a new one
    const block = await client.getBlock();
    const type = typeof block.baseFeePerGas === 'bigint' ? 'eip1559' : 'legacy';
    const feeData = await client.estimateFeesPerGas({ block, type });
    const gasPrice = feeData.maxFeePerGas !== undefined && feeData.maxPriorityFeePerGas !== undefined
        ? { standard: { maxFeePerGas: feeData.maxFeePerGas, maxPriorityFeePerGas: feeData.maxPriorityFeePerGas } }
        : { standard: { gasPrice: feeData.gasPrice } };
    return gasPrice;
}
//# sourceMappingURL=rpc-gas-price-source.js.map