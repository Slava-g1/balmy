"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrioritizedGasPriceSourceCombinator = void 0;
const requirements_and_support_1 = require("../../../shared/requirements-and-support");
// This source will take a list of sources, sorted by priority, and use the first one possible
// that supports the given chain
class PrioritizedGasPriceSourceCombinator {
    constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
            throw new Error('No sources were specified');
    }
    supportedSpeeds() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedSpeeds());
    }
    async getGasPrice({ chainId, config, }) {
        const sourcesInChain = this.sources.filter((source) => chainId in source.supportedSpeeds() && (0, requirements_and_support_1.couldSupportMeetRequirements)(source.supportedSpeeds()[chainId], config?.fields));
        if (sourcesInChain.length === 0)
            throw new Error(`Chain with id ${chainId} cannot support the given requirements`);
        const gasResults = sourcesInChain.map((source) => source.getGasPrice({ chainId, config }).catch(() => ({})));
        return new Promise(async (resolve, reject) => {
            for (let i = 0; i < gasResults.length; i++) {
                const response = await gasResults[i];
                if (Object.keys(response).length > 0 && (0, requirements_and_support_1.doesResponseMeetRequirements)(response, config?.fields)) {
                    resolve(response);
                }
            }
            reject(new Error('Could not fetch gas prices that met the given requirements'));
        });
    }
}
exports.PrioritizedGasPriceSourceCombinator = PrioritizedGasPriceSourceCombinator;
//# sourceMappingURL=prioritized-gas-price-source-combinator.js.map