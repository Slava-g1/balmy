"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedAllowanceSource = void 0;
const concurrent_lru_cache_1 = require("../../../shared/concurrent-lru-cache");
class CachedAllowanceSource {
    constructor(source, config) {
        this.source = source;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCache({
            calculate: (ownerSpendersInChain) => this.fetchTokens(ownerSpendersInChain),
            config,
        });
    }
    supportedChains() {
        return this.source.supportedChains();
    }
    async getAllowances({ allowances, config, }) {
        const keys = allowanceChecksToKeys(allowances);
        const result = await this.cache.getOrCalculate({ keys, timeout: config?.timeout });
        return keyResultsToResult(result);
    }
    async fetchTokens(keys) {
        const allowances = keysToAllowanceChecks(keys);
        const result = await this.source.getAllowances({ allowances });
        return resultsToKeyResults(result);
    }
}
exports.CachedAllowanceSource = CachedAllowanceSource;
function allowanceChecksToKeys(allowances) {
    return allowances.map(({ chainId, token, owner, spender }) => toKey(chainId, token, owner, spender));
}
function resultsToKeyResults(result) {
    const keyResults = {};
    for (const chainId in result) {
        for (const token in result[chainId]) {
            for (const owner in result[chainId][token]) {
                for (const spender in result[chainId][token][owner]) {
                    const key = toKey(Number(chainId), token, owner, spender);
                    keyResults[key] = result[chainId][token][owner][spender];
                }
            }
        }
    }
    return keyResults;
}
function keysToAllowanceChecks(keys) {
    return keys.map(fromKey);
}
function keyResultsToResult(keyResults) {
    const result = {};
    for (const [key, amount] of Object.entries(keyResults)) {
        const { chainId, token, owner, spender } = fromKey(key);
        if (!(chainId in result))
            result[chainId] = {};
        if (!(token in result[chainId]))
            result[chainId][token] = {};
        if (!(owner in result[chainId][token]))
            result[chainId][token][owner] = {};
        result[chainId][token][owner][spender] = amount;
    }
    return result;
}
function toKey(chainId, token, owner, spender) {
    return `${chainId}-${token}-${owner}-${spender}`;
}
function fromKey(key) {
    const [chainId, token, owner, spender] = key.split('-');
    return { chainId: Number(chainId), token, owner, spender };
}
//# sourceMappingURL=cached-allowance-source.js.map