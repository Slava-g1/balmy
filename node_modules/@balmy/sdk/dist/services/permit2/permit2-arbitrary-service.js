"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Permit2ArbitraryService = void 0;
const viem_1 = require("viem");
const utils_1 = require("../../shared/utils");
const permit2_adapter_1 = __importDefault(require("../../shared/abis/permit2-adapter"));
const config_1 = require("./utils/config");
class Permit2ArbitraryService {
    constructor(permit2Service) {
        this.permit2Service = permit2Service;
        this.permit2AdapterContract = config_1.PERMIT2_ADAPTER_CONTRACT;
    }
    preparePermitData(args) {
        return this.permit2Service.preparePermitData({ ...args, spender: this.permit2AdapterContract.address(args.chainId) });
    }
    prepareBatchPermitData(args) {
        return this.permit2Service.prepareBatchPermitData({ ...args, spender: this.permit2AdapterContract.address(args.chainId) });
    }
    buildArbitraryCallWithPermit(params) {
        return this.buildArbitraryCallInternal({
            ...params,
            functionName: 'executeWithPermit',
        });
    }
    buildArbitraryCallWithBatchPermit(params) {
        return this.buildArbitraryCallInternal({
            ...params,
            functionName: 'executeWithBatchPermit',
        });
    }
    buildArbitraryCallWithoutPermit(params) {
        const permitData = {
            tokens: [],
            nonce: 0,
            signature: '0x',
            deadline: (0, utils_1.calculateDeadline)(params.txValidFor),
        };
        return this.buildArbitraryCallInternal({
            ...params,
            permitData,
            chainId: params.chainId,
            functionName: 'executeWithBatchPermit',
        });
    }
    buildArbitraryCallInternal({ permitData: { deadline, ...permitData }, calls, allowanceTargets, distribution, chainId, functionName, }) {
        if (calls.length === 0)
            throw new Error('Must submit at least one call');
        const repeatedToken = findRepeatedKey(distribution ?? {});
        if (repeatedToken)
            throw new Error(`Found token '${repeatedToken}' more than once, with different casing`);
        const allowances = allowanceTargets?.map(({ token, target }) => ({ token, allowanceTarget: target })) ?? [];
        const encodedCalls = calls.map((call) => 'data' in call
            ? {
                target: call.to,
                data: call.data,
                value: call.value ?? 0,
            }
            : {
                target: call.address,
                data: (0, viem_1.encodeFunctionData)({
                    abi: 'json' in call.abi ? call.abi.json : (0, viem_1.parseAbi)(call.abi.humanReadable),
                    functionName: call.functionName,
                    args: call.args ?? [],
                }),
                value: call.value ?? 0,
            });
        const transferOut = Object.entries(distribution ?? {}).map(([token, distribution]) => ({ token, distribution }));
        const totalValue = calls.reduce((sum, { value }) => sum + BigInt(value ?? 0), 0n);
        const data = (0, viem_1.encodeFunctionData)({
            abi: permit2_adapter_1.default, // We cast as any to avoid type checks
            functionName,
            args: [permitData, allowances, encodedCalls, transferOut, deadline],
        });
        return {
            to: this.permit2AdapterContract.address(chainId),
            data,
            value: totalValue,
        };
    }
}
exports.Permit2ArbitraryService = Permit2ArbitraryService;
function findRepeatedKey(object) {
    const keys = new Set();
    for (const key in object) {
        const lower = key.toLowerCase();
        if (keys.has(lower)) {
            return key;
        }
        keys.add(lower);
    }
    return undefined;
}
//# sourceMappingURL=permit2-arbitrary-service.js.map