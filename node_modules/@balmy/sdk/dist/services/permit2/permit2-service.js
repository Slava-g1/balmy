"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Permit2Service = void 0;
const permit2_arbitrary_service_1 = require("./permit2-arbitrary-service");
const config_1 = require("./utils/config");
const utils_1 = require("../../shared/utils");
const eip712_types_1 = require("./utils/eip712-types");
const permit2_1 = __importDefault(require("../../shared/abis/permit2"));
const constants_1 = require("../../shared/constants");
const permit2_quote_service_1 = require("./permit2-quote-service");
const utils_2 = require("../providers/utils");
class Permit2Service {
    constructor(providerService, quoteService, gasService) {
        this.permit2Contract = config_1.PERMIT2_CONTRACT;
        this.arbitrary = new permit2_arbitrary_service_1.Permit2ArbitraryService(this);
        this.quotes = new permit2_quote_service_1.Permit2QuoteService(this, quoteService, providerService, gasService);
        this.providerService = providerService;
    }
    async calculateNonce({ chainId, appId, user }) {
        // Calculate words based on seed word
        const words = new Array(config_1.WORDS_FOR_NONCE_CALCULATION).fill(0).map((_, i) => BigInt(appId) + BigInt(i));
        // Fetch bitmaps for user's words
        const contracts = words.map((word) => ({
            address: this.permit2Contract.address(chainId),
            abi: permit2_1.default,
            functionName: 'nonceBitmap',
            args: [user, word],
        }));
        const results = contracts.length
            ? await this.providerService
                .getViemPublicClient({ chainId })
                .multicall({ contracts, allowFailure: false, multicallAddress: utils_2.MULTICALL_CONTRACT.address(chainId), batchSize: 0 })
            : [];
        // Find nonce
        for (let i = 0; i < results.length; i++) {
            const result = BigInt(results[i]);
            if (result < constants_1.Uint.MAX_256) {
                return (words[i] << 8n) + findUnusedBit(result);
            }
        }
        throw new Error('No nonce found');
    }
    async preparePermitData({ appId, chainId, spender, token, amount, signerAddress, signatureValidFor, }) {
        const nonce = await this.calculateNonce({ chainId, appId, user: signerAddress });
        const deadline = BigInt((0, utils_1.calculateDeadline)(signatureValidFor));
        return {
            dataToSign: {
                types: eip712_types_1.PERMIT2_TRANSFER_FROM_TYPES,
                domain: {
                    name: 'Permit2',
                    chainId,
                    verifyingContract: this.permit2Contract.address(chainId),
                },
                message: {
                    permitted: { token, amount: BigInt(amount) },
                    spender,
                    nonce,
                    deadline,
                },
                primaryType: 'PermitTransferFrom',
            },
            permitData: {
                token,
                amount: BigInt(amount),
                nonce,
                deadline,
            },
        };
    }
    async prepareBatchPermitData({ appId, chainId, spender, tokens, signerAddress, signatureValidFor, }) {
        const nonce = await this.calculateNonce({ chainId, appId, user: signerAddress });
        const deadline = BigInt((0, utils_1.calculateDeadline)(signatureValidFor));
        return {
            dataToSign: {
                types: eip712_types_1.PERMIT2_BATCH_TRANSFER_FROM_TYPES,
                domain: {
                    name: 'Permit2',
                    chainId,
                    verifyingContract: this.permit2Contract.address(chainId),
                },
                message: {
                    permitted: Object.entries(tokens).map(([token, amount]) => ({ token, amount: BigInt(amount) })),
                    spender,
                    nonce,
                    deadline,
                },
                primaryType: 'PermitBatchTransferFrom',
            },
            permitData: {
                nonce,
                deadline,
                tokens: Object.entries(tokens).map(([token, amount]) => ({ token, amount: BigInt(amount) })),
            },
        };
    }
}
exports.Permit2Service = Permit2Service;
function findUnusedBit(value) {
    const binaryString = value.toString(2).padStart(256, '0');
    for (let i = 0; i < 256; i++) {
        if (binaryString[binaryString.length - 1 - i] === '0') {
            return BigInt(i);
        }
    }
    throw new Error('Expected to find an unused bit');
}
//# sourceMappingURL=permit2-service.js.map