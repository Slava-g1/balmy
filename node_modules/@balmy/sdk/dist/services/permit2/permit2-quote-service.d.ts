import { EstimatedQuoteResponseWithTx, IPermit2QuoteService, IPermit2Service, PermitData, SinglePermitParams } from './types';
import { Address, ChainId, TimeString } from '../../types';
import { CompareQuotesBy, CompareQuotesUsing, IQuoteService } from '../quotes';
import { EstimatedQuoteRequest, IgnoreFailedResponses, QuoteResponseWithTx, SourceMetadata } from '../quotes/types';
import { Either } from '../../utility-types';
import { IGasService } from '../gas';
import { IProviderService } from '..';
export declare class Permit2QuoteService implements IPermit2QuoteService {
    private readonly permit2Service;
    private readonly quotesService;
    private readonly providerService;
    private readonly gasService;
    readonly permit2AdapterContract: import("../..").Contract;
    constructor(permit2Service: IPermit2Service, quotesService: IQuoteService, providerService: IProviderService, gasService: IGasService);
    preparePermitData(args: SinglePermitParams): Promise<PermitData>;
    supportedSources(): {
        [k: string]: SourceMetadata;
    };
    supportedChains(): number[];
    supportedSourcesInChain({ chainId }: {
        chainId: ChainId;
    }): {
        [k: string]: SourceMetadata;
    };
    supportedGasSpeeds(): Record<number, import("../../types").SupportInChain<Partial<Record<"standard" | "fast" | "instant", import("../gas").LegacyGasPrice | import("../gas").EIP1159GasPrice>>>>;
    estimateQuotes({ request, config }: {
        request: EstimatedQuoteRequest;
        config?: {
            timeout?: TimeString;
        };
    }): Record<string, Promise<EstimatedQuoteResponseWithTx>>;
    estimateAllQuotes<IgnoreFailed extends boolean = true>({ request, config, }: {
        request: EstimatedQuoteRequest;
        config?: {
            ignoredFailed?: IgnoreFailed;
            sort?: {
                by: CompareQuotesBy;
                using?: CompareQuotesUsing;
            };
            timeout?: TimeString;
        };
    }): Promise<IgnoreFailedResponses<IgnoreFailed, EstimatedQuoteResponseWithTx>[]>;
    buildAndSimulateQuotes<IgnoreFailed extends boolean = true>({ chainId, quotes: estimatedQuotes, config, ...quoteData }: {
        chainId: ChainId;
        quotes: EstimatedQuoteResponseWithTx[];
        takerAddress: Address;
        recipient?: Address;
        config?: {
            ignoredFailed?: IgnoreFailed;
            sort?: {
                by: CompareQuotesBy;
                using?: CompareQuotesUsing;
            };
        };
    } & Either<{
        permitData?: PermitData['permitData'] & {
            signature: string;
        };
    }, {
        txValidFor?: TimeString;
    }>): Promise<IgnoreFailedResponses<IgnoreFailed, QuoteResponseWithTx>[]>;
    private verifyAndCorrect;
    private simulate;
}
