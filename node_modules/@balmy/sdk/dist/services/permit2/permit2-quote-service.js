"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Permit2QuoteService = void 0;
const config_1 = require("./utils/config");
const quotes_1 = require("../quotes");
const quote_service_1 = require("../quotes/quote-service");
const utils_1 = require("../../shared/utils");
const viem_1 = require("viem");
const permit2_adapter_1 = __importDefault(require("../../shared/abis/permit2-adapter"));
const constants_1 = require("../../shared/constants");
class Permit2QuoteService {
    constructor(permit2Service, quotesService, providerService, gasService) {
        this.permit2Service = permit2Service;
        this.quotesService = quotesService;
        this.providerService = providerService;
        this.gasService = gasService;
        this.permit2AdapterContract = config_1.PERMIT2_ADAPTER_CONTRACT;
    }
    preparePermitData(args) {
        return this.permit2Service.preparePermitData({ ...args, spender: this.permit2AdapterContract.address(args.chainId) });
    }
    supportedSources() {
        const supportedChains = this.supportedChains();
        // Filter out unsupported chains
        const sources = Object.entries(this.quotesService.supportedSources()).map(([sourceId, source]) => [
            sourceId,
            { ...source, supports: { ...source.supports, chains: source.supports.chains.filter((chainId) => supportedChains.includes(chainId)) } },
        ]);
        return Object.fromEntries(sources);
    }
    supportedChains() {
        return config_1.PERMIT2_SUPPORTED_CHAINS;
    }
    supportedSourcesInChain({ chainId }) {
        const sourcesInChain = Object.entries(this.supportedSources()).filter(([, source]) => source.supports.chains.includes(chainId));
        return Object.fromEntries(sourcesInChain);
    }
    supportedGasSpeeds() {
        return this.quotesService.supportedGasSpeeds();
    }
    estimateQuotes({ request, config }) {
        const quotes = this.quotesService.getQuotes({
            request: { ...request, takerAddress: this.permit2AdapterContract.address(request.chainId) },
            config: config,
        });
        const txs = this.quotesService.buildTxs({ quotes, config });
        const result = {};
        for (const sourceId in quotes) {
            result[sourceId] = Promise.all([quotes[sourceId], txs[sourceId]]).then(([{ accounts, ...quote }, estimatedTx]) => ({
                ...quote,
                customData: {
                    ...quote.customData,
                    estimatedTx,
                },
            }));
        }
        return result;
    }
    async estimateAllQuotes({ request, config, }) {
        const metadata = this.supportedSources();
        const quotes = Object.entries(this.estimateQuotes({ request, config })).map(([sourceId, response]) => (0, quote_service_1.handleResponseFailure)(sourceId, response, metadata));
        const responses = await Promise.all(quotes);
        const successfulQuotes = responses.filter((response) => !('failed' in response));
        const failedQuotes = config?.ignoredFailed === false ? responses.filter((response) => 'failed' in response) : [];
        const sortedQuotes = (0, quotes_1.sortQuotesBy)(successfulQuotes, config?.sort?.by ?? 'most-swapped', config?.sort?.using ?? 'sell/buy amounts');
        return [...sortedQuotes, ...failedQuotes];
    }
    async buildAndSimulateQuotes({ chainId, quotes: estimatedQuotes, config, ...quoteData }) {
        const quotes = estimatedQuotes.map((estimatedQuote) => buildRealQuote(quoteData, estimatedQuote, chainId));
        const encoded = quotes.filter((response) => !('failed' in response));
        const responses = await this.verifyAndCorrect(chainId, quoteData.takerAddress, encoded);
        if (config?.sort) {
            const successfulQuotes = responses.filter((response) => !('failed' in response));
            const failedQuotes = config?.ignoredFailed === false
                ? [
                    ...quotes.filter((response) => 'failed' in response),
                    ...responses.filter((response) => 'failed' in response),
                ]
                : [];
            const sortedQuotes = (0, quotes_1.sortQuotesBy)(successfulQuotes, config.sort.by, config.sort.using ?? 'sell/buy amounts');
            return [...sortedQuotes, ...failedQuotes];
        }
        // Don't sort, but filter out failed if needed
        const result = config?.ignoredFailed === false ? responses : responses.filter((response) => !('failed' in response));
        return result;
    }
    async verifyAndCorrect(chainId, takerAddress, quotes) {
        const calls = quotes.map(({ tx }) => tx.data);
        const maxValue = quotes.reduce((max, { tx: { value } }) => (value && max < (BigInt(value) ?? 0n) ? BigInt(value) : max), 0n);
        const [gasCalculator, encodedResults] = await Promise.all([
            this.gasService.getQuickGasCalculator({ chainId, config: { timeout: '2s' } }),
            this.simulate({ chainId, calls, account: takerAddress, value: maxValue }),
        ]);
        const decodedResults = encodedResults.map(({ success, result, gasSpent }) => {
            const [amountIn, amountOut] = success ? (0, viem_1.decodeAbiParameters)((0, viem_1.parseAbiParameters)('uint256 amountIn, uint256 amountOut'), result) : [0n, 0n];
            return { success, gasSpent, amountIn, amountOut, rawResult: result };
        });
        return quotes.map((quote, i) => {
            const { success, amountIn, amountOut, gasSpent, rawResult } = decodedResults[i];
            if (!success) {
                return {
                    failed: true,
                    source: {
                        id: quote.source.id,
                        name: quote.source.name,
                        logoURI: quote.source.logoURI,
                    },
                    error: `Failed with ${rawResult}`,
                };
            }
            const sellAmount = (0, utils_1.toAmountsOfToken)({ ...quote.sellToken, amount: amountIn });
            const buyAmount = (0, utils_1.toAmountsOfToken)({ ...quote.buyToken, amount: amountOut });
            const gasCost = gasCalculator.calculateGasCost({ gasEstimation: gasSpent });
            let gas = undefined;
            if (quote.gas) {
                gas = {
                    estimatedGas: gasSpent,
                    ...(0, quote_service_1.calculateGasDetails)(quote.gas.gasTokenSymbol, gasCost['standard'].gasCostNativeToken, quote.gas.gasTokenPrice),
                };
            }
            return { ...quote, sellAmount, buyAmount, gas };
        });
    }
    async simulate({ chainId, calls, account, value, }) {
        const { result } = await this.providerService.getViemPublicClient({ chainId }).simulateContract({
            address: this.permit2AdapterContract.address(chainId),
            abi: permit2_adapter_1.default,
            functionName: 'simulate',
            args: [calls],
            account: account,
            value: value ?? 0n,
        });
        return result;
    }
}
exports.Permit2QuoteService = Permit2QuoteService;
function buildRealQuote({ takerAddress, recipient, permitData, txValidFor, }, quote, chainId) {
    try {
        recipient = recipient ?? takerAddress;
        const deadline = BigInt(permitData?.deadline ?? (0, utils_1.calculateDeadline)(txValidFor) ?? (0, utils_1.calculateDeadline)('1w'));
        // Note: when selling native, we can end up with issues if maxSellAmount != value. So the idea would be to simply use the value
        const maxSellAmount = (0, utils_1.isSameAddress)(quote.sellToken.address, constants_1.Addresses.NATIVE_TOKEN)
            ? quote.customData.estimatedTx.value ?? 0n
            : quote.maxSellAmount.amount;
        const data = quote.type === 'sell'
            ? (0, viem_1.encodeFunctionData)({
                abi: permit2_adapter_1.default,
                functionName: 'sellOrderSwap',
                args: [
                    {
                        deadline,
                        tokenIn: mapIfNative(quote.sellToken.address),
                        amountIn: maxSellAmount,
                        nonce: permitData ? permitData.nonce : 0n,
                        signature: permitData?.signature ?? '0x',
                        allowanceTarget: quote.source.allowanceTarget,
                        swapper: quote.customData.estimatedTx.to,
                        swapData: quote.customData.estimatedTx.data,
                        tokenOut: mapIfNative(quote.buyToken.address),
                        minAmountOut: quote.minBuyAmount.amount,
                        transferOut: [{ recipient: recipient, shareBps: 0n }],
                        misc: '0x',
                    },
                ],
            })
            : (0, viem_1.encodeFunctionData)({
                abi: permit2_adapter_1.default,
                functionName: 'buyOrderSwap',
                args: [
                    {
                        deadline,
                        tokenIn: mapIfNative(quote.sellToken.address),
                        maxAmountIn: maxSellAmount,
                        nonce: permitData ? permitData.nonce : 0n,
                        signature: permitData?.signature ?? '0x',
                        allowanceTarget: quote.source.allowanceTarget,
                        swapper: quote.customData.estimatedTx.to,
                        swapData: quote.customData.estimatedTx.data,
                        tokenOut: mapIfNative(quote.buyToken.address),
                        amountOut: quote.minBuyAmount.amount,
                        transferOut: [{ recipient: recipient, shareBps: 0n }],
                        unspentTokenInRecipient: takerAddress,
                        misc: '0x',
                    },
                ],
            });
        return {
            ...quote,
            accounts: { takerAddress, recipient },
            tx: {
                ...quote.customData.estimatedTx,
                from: takerAddress,
                to: config_1.PERMIT2_ADAPTER_CONTRACT.address(chainId),
                data,
            },
        };
    }
    catch (e) {
        return {
            failed: true,
            source: quote.source,
            error: `Failed to encode params: ${e.message}`,
        };
    }
}
function mapIfNative(token) {
    return (0, utils_1.isSameAddress)(token, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : token;
}
//# sourceMappingURL=permit2-quote-service.js.map