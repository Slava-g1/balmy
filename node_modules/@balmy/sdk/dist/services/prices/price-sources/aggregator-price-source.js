"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatorPriceSource = void 0;
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("../../../shared/utils");
const utils_2 = require("./utils");
class AggregatorPriceSource {
    constructor(sources, method) {
        this.sources = sources;
        this.method = method;
        if (sources.length === 0)
            throw new Error('No sources were specified');
    }
    supportedQueries() {
        return (0, utils_2.combineSupport)(this.sources);
    }
    async getCurrentPrices({ tokens, config }) {
        const collected = await collectAllResults({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getCurrentPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getCurrentPrices({
                tokens: filteredRequest,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
        return this.aggregate(collected, aggregatePrices);
    }
    async getHistoricalPrices({ tokens, timestamp, searchWidth, config, }) {
        const collected = await collectAllResults({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getHistoricalPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getHistoricalPrices({
                tokens: filteredRequest,
                timestamp,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
        return this.aggregate(collected, aggregatePrices);
    }
    async getBulkHistoricalPrices({ tokens, searchWidth, config, }) {
        const collected = await collectAllResults({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getBulkHistoricalPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getBulkHistoricalPrices({
                tokens: filteredRequest,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
        return this.aggregate(collected, aggregateBulkHistoricalPrices);
    }
    async getChart({ tokens, span, period, bound, searchWidth, config, }) {
        // TODO: Support more than one source
        const sourcesInChains = (0, utils_2.getSourcesThatSupportRequestOrFail)(tokens, this.sources, 'getChart');
        return sourcesInChains[0].getChart({ tokens, span, period, bound, searchWidth, config }) ?? {};
    }
    aggregate(collected, aggregate) {
        const result = {};
        for (const chainId in collected) {
            result[chainId] = {};
            for (const address in collected[chainId]) {
                result[chainId][address] = aggregate(collected[chainId][address], this.method);
            }
        }
        return result;
    }
}
exports.AggregatorPriceSource = AggregatorPriceSource;
async function collectAllResults({ allSources, fullRequest, query, getResult, timeout, }) {
    const sourcesInChains = (0, utils_2.getSourcesThatSupportRequestOrFail)(fullRequest, allSources, query);
    const reducedTimeout = (0, timeouts_1.reduceTimeout)(timeout, '100');
    const promises = sourcesInChains.map((source) => (0, timeouts_1.timeoutPromise)(getResult(source, (0, utils_2.filterRequestForSource)(fullRequest, query, source), reducedTimeout), reducedTimeout, {
        description: 'Timeouted while executing an aggregated price query',
    }));
    const results = await (0, utils_1.filterRejectedResults)(promises);
    return collect(results);
}
function collect(results) {
    const collected = {};
    for (const result of results) {
        for (const chainId in result) {
            if (!(chainId in collected)) {
                collected[chainId] = {};
            }
            for (const address in result[chainId]) {
                if (!(address in collected[chainId])) {
                    collected[chainId][address] = [];
                }
                if (typeof result?.[chainId]?.[address] !== 'undefined') {
                    collected[chainId][address].push(result[chainId][address]);
                }
            }
        }
    }
    return collected;
}
function aggregatePrices(results, method) {
    const sorted = results.sort((a, b) => a.price - b.price);
    switch (method) {
        case 'median':
            if (sorted.length > 0 && sorted.length % 2 === 0) {
                const middleLow = sorted[sorted.length / 2 - 1];
                const middleHigh = sorted[sorted.length / 2];
                return {
                    price: (middleLow.price + middleHigh.price) / 2,
                    closestTimestamp: (middleLow.closestTimestamp + middleHigh.closestTimestamp) / 2,
                };
            }
            else {
                return sorted[Math.floor(sorted.length / 2)];
            }
        case 'avg':
            const sumPrice = sumAll(results.map(({ price }) => price));
            const sumTimestamp = sumAll(results.map(({ closestTimestamp: timestamp }) => timestamp));
            return {
                price: sumPrice / results.length,
                closestTimestamp: sumTimestamp / results.length,
            };
        case 'max':
            return sorted[sorted.length - 1];
        case 'min':
            return sorted[0];
    }
}
function aggregateBulkHistoricalPrices(results, method) {
    const allTimestamps = [...new Set(results.flatMap((result) => Object.keys(result)))].map(Number);
    const collectedByTimestamp = allTimestamps.map((timestamp) => ({ timestamp, results: extractResultInTimestamp(timestamp, results) }));
    return Object.fromEntries(collectedByTimestamp.map(({ timestamp, results }) => [timestamp, aggregatePrices(results, method)]));
}
function extractResultInTimestamp(timestamp, results) {
    return results.filter((result) => timestamp in result).map((result) => result[timestamp]);
}
function sumAll(array) {
    return array.reduce((accum, curr) => accum + curr, 0);
}
//# sourceMappingURL=aggregator-price-source.js.map