"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nowInSeconds = exports.getSourcesThatSupportRequestOrFail = exports.combineSupport = exports.filterRequestForSource = exports.doesResponseFulfillRequest = exports.fillResponseWithNewResult = void 0;
function fillResponseWithNewResult(result, newResult) {
    for (const chainId in newResult) {
        for (const address in newResult[chainId]) {
            if (!result[chainId]?.[address]) {
                if (!(chainId in result)) {
                    result[chainId] = {};
                }
                result[chainId][address] = newResult[chainId][address];
            }
        }
    }
}
exports.fillResponseWithNewResult = fillResponseWithNewResult;
function doesResponseFulfillRequest(result, request) {
    for (const chainId in request) {
        for (const address of request[chainId]) {
            if (typeof result[chainId]?.[address] === 'undefined') {
                return false;
            }
        }
    }
    return true;
}
exports.doesResponseFulfillRequest = doesResponseFulfillRequest;
function doesSourceSupportQueryInAnyOfTheChains(source, query, chains) {
    const support = source.supportedQueries();
    return chains.some((chainId) => support[chainId]?.[query]);
}
function filterRequestForSource(request, query, source) {
    const support = source.supportedQueries();
    return request.filter(({ chainId }) => support[chainId]?.[query]);
}
exports.filterRequestForSource = filterRequestForSource;
function combineSupport(sources) {
    const result = {};
    for (const source of sources) {
        for (const [chainIdString, support] of Object.entries(source.supportedQueries())) {
            const chainId = Number(chainIdString);
            const current = result[chainId] ?? {
                getCurrentPrices: false,
                getHistoricalPrices: false,
                getBulkHistoricalPrices: false,
                getChart: false,
            };
            result[chainId] = {
                getCurrentPrices: current.getCurrentPrices || support.getCurrentPrices,
                getHistoricalPrices: current.getHistoricalPrices || support.getHistoricalPrices,
                getBulkHistoricalPrices: current.getBulkHistoricalPrices || support.getBulkHistoricalPrices,
                getChart: current.getChart || support.getChart,
            };
        }
    }
    return result;
}
exports.combineSupport = combineSupport;
function getSourcesThatSupportRequestOrFail(request, sources, query) {
    const chainsInRequest = [...new Set(request.map(({ chainId }) => chainId))];
    const sourcesInChain = sources.filter((source) => doesSourceSupportQueryInAnyOfTheChains(source, query, chainsInRequest));
    if (sourcesInChain.length === 0)
        throw new Error(`Current price sources can't support all the given chains`);
    return sourcesInChain;
}
exports.getSourcesThatSupportRequestOrFail = getSourcesThatSupportRequestOrFail;
function nowInSeconds() {
    return Math.floor(Date.now() / 1000);
}
exports.nowInSeconds = nowInSeconds;
//# sourceMappingURL=utils.js.map