import { ChainId, TimeString, Timestamp, TokenAddress } from '../../../types';
import { CacheConfig } from '../../../shared/concurrent-lru-cache';
import { PriceResult, IPriceSource, PriceInput } from '../types';
export declare class CachedPriceSource implements IPriceSource {
    private readonly source;
    private readonly cache;
    constructor(source: IPriceSource, config: CacheConfig);
    supportedQueries(): Record<number, import("../types").PricesQueriesSupport>;
    getCurrentPrices({ tokens, config, }: {
        tokens: PriceInput[];
        config?: {
            timeout?: TimeString;
        };
    }): Promise<Record<ChainId, Record<TokenAddress, PriceResult>>>;
    getHistoricalPrices({ tokens, timestamp, searchWidth, config, }: {
        tokens: PriceInput[];
        timestamp: Timestamp;
        searchWidth?: TimeString;
        config?: {
            timeout?: TimeString;
        };
    }): Promise<Record<ChainId, Record<TokenAddress, PriceResult>>>;
    getBulkHistoricalPrices({ tokens, searchWidth, config, }: {
        tokens: {
            chainId: ChainId;
            token: TokenAddress;
            timestamp: Timestamp;
        }[];
        searchWidth: TimeString | undefined;
        config: {
            timeout?: TimeString;
        } | undefined;
    }): Promise<Record<ChainId, Record<TokenAddress, Record<Timestamp, PriceResult>>>>;
    getChart({ tokens, span, period, bound, searchWidth, config, }: {
        tokens: PriceInput[];
        span: number;
        period: TimeString;
        bound: {
            from: Timestamp;
        } | {
            upTo: Timestamp | 'now';
        };
        searchWidth?: TimeString;
        config: {
            timeout?: TimeString;
        } | undefined;
    }): Promise<Record<ChainId, Record<TokenAddress, PriceResult[]>>>;
    private fetchTokens;
}
