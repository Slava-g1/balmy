"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FastestPriceSource = void 0;
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("./utils");
const utils_2 = require("../../../shared/utils");
// This source will take a list of sources and combine the results of each one to try to fulfill
// the request. As soon as there there is a response that is valid for the request, it will be returned
class FastestPriceSource {
    constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
            throw new Error('No sources were specified');
    }
    supportedQueries() {
        return (0, utils_1.combineSupport)(this.sources);
    }
    getCurrentPrices({ tokens, config }) {
        return executeFastest({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getCurrentPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getCurrentPrices({
                tokens: filteredRequest,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
    getHistoricalPrices({ tokens, timestamp, searchWidth, config, }) {
        return executeFastest({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getHistoricalPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getHistoricalPrices({
                tokens: filteredRequest,
                timestamp,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
    getBulkHistoricalPrices({ tokens, searchWidth, config, }) {
        return executeFastest({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getBulkHistoricalPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getBulkHistoricalPrices({
                tokens: filteredRequest,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
    async getChart({ tokens, span, period, bound, searchWidth, config, }) {
        return executeFastest({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getChart',
            getResult: (source, filteredRequest, sourceTimeout) => source.getChart({
                tokens: filteredRequest,
                span,
                period,
                bound,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
}
exports.FastestPriceSource = FastestPriceSource;
async function executeFastest({ allSources, fullRequest, query, getResult, timeout, }) {
    const sourcesInChains = (0, utils_1.getSourcesThatSupportRequestOrFail)(fullRequest, allSources, query);
    const reducedTimeout = (0, timeouts_1.reduceTimeout)(timeout, '100');
    const addressesPerChain = (0, utils_2.groupByChain)(fullRequest, ({ token }) => token);
    return new Promise(async (resolve) => {
        const result = {};
        const allPromises = sourcesInChains.map((source) => (0, timeouts_1.timeoutPromise)(getResult(source, (0, utils_1.filterRequestForSource)(fullRequest, query, source), reducedTimeout), reducedTimeout).then((response) => {
            (0, utils_1.fillResponseWithNewResult)(result, response);
            if ((0, utils_1.doesResponseFulfillRequest)(result, addressesPerChain)) {
                resolve(result);
            }
        }));
        Promise.allSettled(allPromises).then(() => {
            if (!(0, utils_1.doesResponseFulfillRequest)(result, addressesPerChain)) {
                // We couldn't fulfil the request, so we know we didn't resolve.
                // We will return whatever we could fetch
                resolve(result);
            }
        });
    });
}
//# sourceMappingURL=fastest-price-source.js.map