"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoingeckoPriceSource = void 0;
const _chains_1 = require("../../../chains");
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("../../../shared/utils");
const constants_1 = require("../../../shared/constants");
const COINGECKO_CHAIN_KEYS = {
    [_chains_1.Chains.ONTOLOGY.chainId]: { chainKey: 'ontology', nativeTokenKey: 'ontology' },
    [_chains_1.Chains.BIT_TORRENT.chainId]: { chainKey: 'bittorrent', nativeTokenKey: 'bittorrent' },
    [_chains_1.Chains.BNB_CHAIN.chainId]: { chainKey: 'binance-smart-chain', nativeTokenKey: 'binancecoin' },
    [_chains_1.Chains.HECO.chainId]: { chainKey: 'huobi-token', nativeTokenKey: 'huobi-token' },
    [_chains_1.Chains.KAIA.chainId]: { chainKey: 'klay-token', nativeTokenKey: 'kaia' },
    [_chains_1.Chains.FANTOM.chainId]: { chainKey: 'fantom', nativeTokenKey: 'fantom' },
    [_chains_1.Chains.OPTIMISM.chainId]: { chainKey: 'optimistic-ethereum', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.POLYGON.chainId]: { chainKey: 'polygon-pos', nativeTokenKey: 'matic-network' },
    [_chains_1.Chains.MOONRIVER.chainId]: { chainKey: 'moonriver', nativeTokenKey: 'moonriver' },
    [_chains_1.Chains.CRONOS.chainId]: { chainKey: 'cronos', nativeTokenKey: 'crypto-com-chain' },
    [_chains_1.Chains.AURORA.chainId]: { chainKey: 'aurora', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.AVALANCHE.chainId]: { chainKey: 'avalanche', nativeTokenKey: 'avalanche-2' },
    [_chains_1.Chains.ETHEREUM.chainId]: { chainKey: 'ethereum', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.HARMONY_SHARD_0.chainId]: { chainKey: 'harmony-shard-0', nativeTokenKey: 'harmony' },
    [_chains_1.Chains.EVMOS.chainId]: { chainKey: 'evmos', nativeTokenKey: 'evmos' },
    [_chains_1.Chains.BOBA.chainId]: { chainKey: 'boba', nativeTokenKey: 'boba-network' },
    [_chains_1.Chains.CELO.chainId]: { chainKey: 'celo', nativeTokenKey: 'celo' },
    [_chains_1.Chains.ASTAR.chainId]: { chainKey: 'astar', nativeTokenKey: 'astar' },
    [_chains_1.Chains.MOONBEAM.chainId]: { chainKey: 'moonbeam', nativeTokenKey: 'moonbeam' },
    [_chains_1.Chains.OASIS_EMERALD.chainId]: { chainKey: 'oasis', nativeTokenKey: 'oasis-network' },
    [_chains_1.Chains.ROOTSTOCK.chainId]: { chainKey: 'rootstock', nativeTokenKey: 'rootstock' },
    [_chains_1.Chains.VELAS.chainId]: { chainKey: 'velas', nativeTokenKey: 'velas' },
    [_chains_1.Chains.OKC.chainId]: { chainKey: 'okex-chain', nativeTokenKey: 'oec-token' },
    [_chains_1.Chains.CANTO.chainId]: { chainKey: 'canto', nativeTokenKey: 'canto' },
    [_chains_1.Chains.FUSE.chainId]: { chainKey: 'fuse', nativeTokenKey: 'fuse-network-token' },
    [_chains_1.Chains.ARBITRUM.chainId]: { chainKey: 'arbitrum-one', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.GNOSIS.chainId]: { chainKey: 'xdai', nativeTokenKey: 'xdai' },
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: { chainKey: 'polygon-zkevm', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.KAVA.chainId]: { chainKey: 'kava', nativeTokenKey: 'kava' },
    [_chains_1.Chains.BASE.chainId]: { chainKey: 'base', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.LINEA.chainId]: { chainKey: 'linea', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.MODE.chainId]: { chainKey: 'mode', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.BLAST.chainId]: { chainKey: 'blast', nativeTokenKey: 'ethereum' },
    [_chains_1.Chains.SCROLL.chainId]: { chainKey: 'scroll', nativeTokenKey: 'ethereum' },
};
class CoingeckoPriceSource {
    constructor(fetch) {
        this.fetch = fetch;
    }
    supportedQueries() {
        const support = {
            getCurrentPrices: true,
            getHistoricalPrices: false,
            getBulkHistoricalPrices: false,
            getChart: false,
        };
        const entries = Object.keys(COINGECKO_CHAIN_KEYS)
            .map(Number)
            .map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
    }
    async getCurrentPrices({ tokens, config, }) {
        const groupedByChain = (0, utils_1.groupByChain)(tokens, ({ token }) => token);
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config?.timeout, '100');
        const promises = Object.entries(groupedByChain).map(async ([chainId, tokens]) => [
            Number(chainId),
            await (0, timeouts_1.timeoutPromise)(this.getCurrentPricesInChain(Number(chainId), tokens, reducedTimeout), reducedTimeout),
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
    }
    getHistoricalPrices(_) {
        // TODO: Add support
        return Promise.reject(new Error('Operation not supported'));
    }
    getBulkHistoricalPrices(_) {
        return Promise.reject(new Error('Operation not supported'));
    }
    async getChart(_) {
        return Promise.reject(new Error('Operation not supported'));
    }
    async getCurrentPricesInChain(chainId, addresses, timeout) {
        const addressesWithoutNativeToken = addresses.filter((address) => !(0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN));
        const [erc20LowerCased, nativePrice] = await Promise.all([
            this.fetchERC20Prices(chainId, addressesWithoutNativeToken, timeout),
            addressesWithoutNativeToken.length !== addresses.length ? this.fetchNativePrice(chainId, timeout) : undefined,
        ]);
        if (nativePrice) {
            erc20LowerCased[constants_1.Addresses.NATIVE_TOKEN.toLowerCase()] = nativePrice;
        }
        return Object.fromEntries(addresses.map((address) => [address, erc20LowerCased[address.toLowerCase()]]));
    }
    async fetchNativePrice(chainId, timeout) {
        const { nativeTokenKey } = COINGECKO_CHAIN_KEYS[chainId];
        const url = `https://api.coingecko.com/api/v3/simple/price?ids=${nativeTokenKey}&vs_currencies=usd&include_last_updated_at=true`;
        const response = await this.fetch.fetch(url, { timeout, headers: { Accept: 'application/json' } });
        const body = await response.json();
        return { price: body[nativeTokenKey].usd, closestTimestamp: body[nativeTokenKey].last_updated_at };
    }
    async fetchERC20Prices(chainId, addresses, timeout) {
        if (addresses.length === 0)
            return {};
        const url = `https://api.coingecko.com/api/v3/simple/token_price/${COINGECKO_CHAIN_KEYS[chainId].chainKey}` +
            `?contract_addresses=${addresses.join(',')}` +
            '&vs_currencies=usd' +
            '&include_last_updated_at=true';
        const response = await this.fetch.fetch(url, { timeout });
        const body = await response.json();
        const entries = Object.entries(body).map(([token, { usd, last_updated_at }]) => [
            token.toLowerCase(),
            { price: usd, timestamp: last_updated_at },
        ]);
        return Object.fromEntries(entries);
    }
}
exports.CoingeckoPriceSource = CoingeckoPriceSource;
//# sourceMappingURL=coingecko-price-source.js.map