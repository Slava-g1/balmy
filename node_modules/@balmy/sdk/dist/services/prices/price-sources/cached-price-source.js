"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedPriceSource = void 0;
const concurrent_lru_cache_1 = require("../../../shared/concurrent-lru-cache");
const utils_1 = require("../../../shared/utils");
class CachedPriceSource {
    constructor(source, config) {
        this.source = source;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCacheWithContext({
            calculate: (context, tokensInChain) => this.fetchTokens(tokensInChain, context),
            config,
        });
    }
    supportedQueries() {
        return this.source.supportedQueries();
    }
    async getCurrentPrices({ tokens, config, }) {
        const tokensInChain = addressesToTokensInChain(tokens);
        const cacheResult = await this.cache.getOrCalculate({ keys: tokensInChain, context: config, timeout: config?.timeout });
        return tokenInChainRecordToChainAndAddress(cacheResult);
    }
    getHistoricalPrices({ tokens, timestamp, searchWidth, config, }) {
        // TODO: Support caching, but make it configurable
        return this.source.getHistoricalPrices({ tokens, timestamp, searchWidth, config });
    }
    getBulkHistoricalPrices({ tokens, searchWidth, config, }) {
        // TODO: Support caching, but make it configurable
        return this.source.getBulkHistoricalPrices({ tokens, searchWidth, config });
    }
    async getChart({ tokens, span, period, bound, searchWidth, config, }) {
        // TODO: Support caching, but make it configurable
        return this.source.getChart({
            tokens,
            span,
            period,
            bound,
            searchWidth,
            config,
        });
    }
    async fetchTokens(tokensInChain, context) {
        const addresses = tokensInChainToAddresses(tokensInChain);
        const tokens = await this.source.getCurrentPrices({ tokens: addresses, config: { timeout: context?.timeout } });
        return chainAndAddressRecordToTokenInChain(tokens);
    }
}
exports.CachedPriceSource = CachedPriceSource;
function addressesToTokensInChain(tokens) {
    return tokens.map(({ chainId, token }) => (0, utils_1.toTokenInChain)(chainId, token));
}
function tokensInChainToAddresses(tokensInChain) {
    return tokensInChain.map((tokenInChain) => {
        const { chainId, address } = (0, utils_1.fromTokenInChain)(tokenInChain);
        return { chainId, token: address };
    });
}
function tokenInChainRecordToChainAndAddress(record) {
    const result = {};
    for (const [tokenInChain, token] of Object.entries(record)) {
        const { chainId, address } = (0, utils_1.fromTokenInChain)(tokenInChain);
        if (!(chainId in result)) {
            result[chainId] = {};
        }
        result[chainId][address] = token;
    }
    return result;
}
function chainAndAddressRecordToTokenInChain(record) {
    const entries = Object.entries(record).flatMap(([chainId, record]) => Object.entries(record).map(([address, token]) => [(0, utils_1.toTokenInChain)(parseInt(chainId), address), token]));
    return Object.fromEntries(entries);
}
//# sourceMappingURL=cached-price-source.js.map