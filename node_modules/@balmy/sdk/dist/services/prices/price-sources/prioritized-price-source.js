"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrioritizedPriceSource = void 0;
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("./utils");
const utils_2 = require("../../../shared/utils");
// This source will take a list of sources, sorted by priority, and combine the results of each
// one to try to fulfill the request. The response will prioritize the sources results based on the prioritized
class PrioritizedPriceSource {
    constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
            throw new Error('No sources were specified');
    }
    supportedQueries() {
        return (0, utils_1.combineSupport)(this.sources);
    }
    async getCurrentPrices({ tokens, config }) {
        return executePrioritized({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getCurrentPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getCurrentPrices({
                tokens: filteredRequest,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
    getHistoricalPrices({ tokens, timestamp, searchWidth, config, }) {
        return executePrioritized({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getHistoricalPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getHistoricalPrices({
                tokens: filteredRequest,
                timestamp,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
    getBulkHistoricalPrices({ tokens, searchWidth, config, }) {
        return executePrioritized({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getBulkHistoricalPrices',
            getResult: (source, filteredRequest, sourceTimeout) => source.getBulkHistoricalPrices({
                tokens: filteredRequest,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
    async getChart({ tokens, span, period, bound, searchWidth, config, }) {
        return executePrioritized({
            allSources: this.sources,
            fullRequest: tokens,
            query: 'getChart',
            getResult: (source, filteredRequest, sourceTimeout) => source.getChart({
                tokens: filteredRequest,
                span,
                period,
                bound,
                searchWidth,
                config: { timeout: sourceTimeout },
            }),
            timeout: config?.timeout,
        });
    }
}
exports.PrioritizedPriceSource = PrioritizedPriceSource;
async function executePrioritized({ allSources, fullRequest, query, getResult, timeout, }) {
    const sourcesInChains = (0, utils_1.getSourcesThatSupportRequestOrFail)(fullRequest, allSources, query);
    const addressesPerChain = (0, utils_2.groupByChain)(fullRequest, ({ token }) => token);
    const reducedTimeout = (0, timeouts_1.reduceTimeout)(timeout, '100');
    return new Promise(async (resolve) => {
        const result = {};
        const fetchPromises = sourcesInChains.map((source) => (0, timeouts_1.timeoutPromise)(getResult(source, (0, utils_1.filterRequestForSource)(fullRequest, query, source), reducedTimeout), reducedTimeout, {
            description: 'Timeouted while executing a prioritized price query',
        }).catch(() => ({})) // Handle rejection and return empty result
        );
        let i = 0;
        while (!(0, utils_1.doesResponseFulfillRequest)(result, addressesPerChain) && i < fetchPromises.length) {
            const response = await fetchPromises[i];
            (0, utils_1.fillResponseWithNewResult)(result, response);
            i++;
        }
        // Return whatever we could fetch
        resolve(result);
    });
}
//# sourceMappingURL=prioritized-price-source.js.map