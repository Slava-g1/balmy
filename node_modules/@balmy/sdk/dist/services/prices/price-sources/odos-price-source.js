"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OdosPriceSource = void 0;
const _chains_1 = require("../../../chains");
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("../../../shared/utils");
const constants_1 = require("../../../shared/constants");
const utils_2 = require("./utils");
const SUPPORTED_CHAINS = [_chains_1.Chains.ETHEREUM, _chains_1.Chains.POLYGON, _chains_1.Chains.OPTIMISM, _chains_1.Chains.AVALANCHE, _chains_1.Chains.ARBITRUM, _chains_1.Chains.BNB_CHAIN, _chains_1.Chains.BASE];
class OdosPriceSource {
    constructor(fetch) {
        this.fetch = fetch;
    }
    supportedQueries() {
        const support = {
            getCurrentPrices: true,
            getHistoricalPrices: false,
            getBulkHistoricalPrices: false,
            getChart: false,
        };
        const entries = SUPPORTED_CHAINS.map(({ chainId }) => chainId).map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
    }
    async getCurrentPrices({ tokens, config, }) {
        const groupedByChain = (0, utils_1.groupByChain)(tokens, ({ token }) => token);
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config?.timeout, '100');
        const promises = Object.entries(groupedByChain).map(async ([chainId, tokens]) => [
            Number(chainId),
            await (0, timeouts_1.timeoutPromise)(this.getCurrentPricesInChain(chainId, tokens, reducedTimeout), reducedTimeout),
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
    }
    getHistoricalPrices(_) {
        return Promise.reject(new Error('Operation not supported'));
    }
    getBulkHistoricalPrices(_) {
        return Promise.reject(new Error('Operation not supported'));
    }
    async getChart(_) {
        return Promise.reject(new Error('Operation not supported'));
    }
    async getCurrentPricesInChain(chainId, addresses, timeout) {
        const params = addresses.map((address) => `token_addresses=${mapToken(address)}`).join('&');
        const url = `https://api.odos.xyz/pricing/token/${chainId}?${params}`;
        const response = await this.fetch.fetch(url, { timeout });
        const body = await response.json();
        const lowercased = toLowerCase(body.tokenPrices);
        return Object.fromEntries(addresses.map((address) => [address, { price: lowercased[mapToken(address.toLowerCase())], closestTimestamp: (0, utils_2.nowInSeconds)() }]));
    }
}
exports.OdosPriceSource = OdosPriceSource;
function mapToken(address) {
    return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : address;
}
function toLowerCase(prices) {
    return Object.fromEntries(Object.entries(prices).map(([token, price]) => [token.toLowerCase(), price]));
}
//# sourceMappingURL=odos-price-source.js.map