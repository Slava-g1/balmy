"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalmyPriceSource = void 0;
const utils_1 = require("../../../shared/utils");
const balmy_quote_source_1 = require("../../quotes/quote-sources/balmy-quote-source");
const utils_2 = require("./utils");
class BalmyPriceSource {
    constructor(fetch, apiKey) {
        this.fetch = fetch;
        this.apiKey = apiKey;
    }
    supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: true, getBulkHistoricalPrices: true, getChart: false };
        const entries = balmy_quote_source_1.BALMY_SUPPORTED_CHAINS.map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
    }
    async getCurrentPrices({ tokens, config, }) {
        const tokensInChain = tokens.map(({ chainId, token }) => (0, utils_1.toTokenInChain)(chainId, token));
        const response = await this.fetch.fetch(`https://api.balmy.xyz/v1/prices?apiKey=${this.apiKey}`, {
            body: JSON.stringify({ tokens: tokensInChain }),
            method: 'POST',
            timeout: config?.timeout,
        });
        const body = await response.json();
        const result = {};
        for (const [tokenInChain, price] of Object.entries(body.tokens)) {
            const { chainId, address } = (0, utils_1.fromTokenInChain)(tokenInChain);
            if (!(chainId in result))
                result[chainId] = {};
            result[chainId][address] = { price, closestTimestamp: (0, utils_2.nowInSeconds)() };
        }
        return result;
    }
    async getHistoricalPrices({ tokens, timestamp, searchWidth, config, }) {
        const input = tokens.map(({ token, chainId }) => ({ chainId, token, timestamp }));
        const prices = await this.getBulkHistoricalPrices({ tokens: input, searchWidth, config });
        return Object.fromEntries(Object.entries(prices).map(([chainId, tokens]) => [
            chainId,
            Object.fromEntries(Object.entries(tokens).map(([token, price]) => [token, price[timestamp]])),
        ]));
    }
    async getBulkHistoricalPrices({ tokens, config, }) {
        const tokensInput = tokens.map(({ chainId, token, timestamp }) => ({ chain: chainId, token, timestamp }));
        const response = await this.fetch.fetch(`https://api.balmy.xyz/v1/historical-prices?apiKey=${this.apiKey}`, {
            body: JSON.stringify({ tokens: tokensInput }),
            method: 'POST',
            timeout: config?.timeout,
        });
        const body = await response.json();
        return body.tokens;
    }
    async getChart(_) {
        return Promise.reject(new Error('Operation not supported'));
    }
}
exports.BalmyPriceSource = BalmyPriceSource;
//# sourceMappingURL=balmy-price-source.js.map