"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSourceList = void 0;
const timeouts_1 = require("../../../shared/timeouts");
const source_registry_1 = require("../source-registry");
const buy_to_sell_order_wrapper_1 = require("../quote-sources/wrappers/buy-to-sell-order-wrapper");
const forced_timeout_wrapper_1 = require("../quote-sources/wrappers/forced-timeout-wrapper");
const errors_1 = require("../errors");
class LocalSourceList {
    constructor({ providerService, fetchService }) {
        this.sources = source_registry_1.QUOTE_SOURCES;
        this.providerService = providerService;
        this.fetchService = fetchService;
    }
    supportedSources() {
        const entries = Object.entries(this.sources).map(([sourceId, source]) => [sourceId, source.getMetadata()]);
        return Object.fromEntries(entries);
    }
    getQuotes(request) {
        return Object.fromEntries(request.sources.map((sourceId) => [sourceId, this.getQuote(request, sourceId)]));
    }
    buildTxs(request) {
        const entries = Object.entries(request.quotes).map(([sourceId, quote]) => [
            sourceId,
            quote.then((response) => (0, timeouts_1.timeoutPromise)(this.buildTx(sourceId, request.sourceConfig, response, request.quoteTimeout), request.quoteTimeout)),
        ]);
        return Object.fromEntries(entries);
    }
    async buildTx(sourceId, sourceConfig, quote, timeout) {
        const source = this.sources[sourceId];
        if (!source)
            throw new errors_1.SourceNotFoundError(sourceId);
        // Check config is valid
        const config = { ...sourceConfig?.global, ...sourceConfig?.custom?.[sourceId] };
        if (!source.isConfigAndContextValidForTxBuilding(config)) {
            throw new errors_1.SourceInvalidConfigOrContextError(sourceId);
        }
        // Map request to source request
        const sourceRequest = mapTxRequestToSourceRequest(quote, timeout);
        const tx = source.buildTx({
            components: { providerService: this.providerService, fetchService: this.fetchService },
            config,
            request: sourceRequest,
        });
        const { to, calldata, value } = await tx;
        return { to, data: calldata, value, from: quote.accounts.takerAddress };
    }
    async getQuote(request, sourceId) {
        if (!(sourceId in this.sources)) {
            throw new errors_1.SourceNotFoundError(sourceId);
        }
        // Map request to source request
        const sourceRequest = mapQuoteRequestToSourceRequest(request);
        // Find and wrap source
        const source = this.getSourceForRequest(request, sourceId);
        // Check config is valid
        const config = { ...request.sourceConfig?.global, ...request.sourceConfig?.custom?.[sourceId] };
        if (!source.isConfigAndContextValidForQuoting(config)) {
            throw new errors_1.SourceInvalidConfigOrContextError(sourceId);
        }
        // Ask for quote
        const response = await source.quote({
            components: { providerService: this.providerService, fetchService: this.fetchService },
            config,
            request: sourceRequest,
        });
        // Map to response
        return mapSourceResponseToResponse({ request, source, response, sourceId });
    }
    getSourceForRequest(request, sourceId) {
        let source = this.sources[sourceId];
        if (request.order.type === 'buy' && !source.getMetadata().supports.buyOrders) {
            if (request.estimateBuyOrdersWithSellOnlySources) {
                source = (0, buy_to_sell_order_wrapper_1.buyToSellOrderWrapper)(source);
            }
            else {
                throw new errors_1.SourceNoBuyOrdersError(sourceId);
            }
        }
        // Cast so that even if the source doesn't support it, everything else types ok
        return (0, forced_timeout_wrapper_1.forcedTimeoutWrapper)(source);
    }
}
exports.LocalSourceList = LocalSourceList;
function mapSourceResponseToResponse({ source, request, response, sourceId, }) {
    const recipient = request.recipient && source.getMetadata().supports.swapAndTransfer ? request.recipient : request.takerAddress;
    return {
        sellAmount: response.sellAmount,
        buyAmount: response.buyAmount,
        maxSellAmount: response.maxSellAmount,
        minBuyAmount: response.minBuyAmount,
        estimatedGas: response.estimatedGas,
        recipient,
        source: {
            id: sourceId,
            allowanceTarget: response.allowanceTarget,
            name: source.getMetadata().name,
            logoURI: source.getMetadata().logoURI,
        },
        type: response.type,
        customData: response.customData,
    };
}
function mapOrderToBigNumber(request) {
    return request.order.type === 'sell'
        ? { type: 'sell', sellAmount: BigInt(request.order.sellAmount) }
        : { type: 'buy', buyAmount: BigInt(request.order.buyAmount) };
}
function mapTxRequestToSourceRequest(response, timeout) {
    return {
        chainId: response.chainId,
        sellToken: response.sellToken.address,
        buyToken: response.buyToken.address,
        type: response.type,
        sellAmount: response.sellAmount.amount,
        maxSellAmount: response.maxSellAmount.amount,
        buyAmount: response.buyAmount.amount,
        minBuyAmount: response.minBuyAmount.amount,
        accounts: { takeFrom: response.accounts.takerAddress, recipient: response.accounts.recipient },
        customData: response.customData,
        config: { timeout },
    };
}
function mapQuoteRequestToSourceRequest(request) {
    return {
        chainId: request.chainId,
        sellToken: request.sellToken,
        buyToken: request.buyToken,
        order: mapOrderToBigNumber(request),
        config: {
            slippagePercentage: request.slippagePercentage,
            txValidFor: request.txValidFor,
            timeout: request.quoteTimeout,
        },
        accounts: {
            takeFrom: request.takerAddress,
            recipient: request.recipient,
        },
        external: request.external,
    };
}
//# sourceMappingURL=local-source-list.js.map