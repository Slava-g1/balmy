"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangoQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("../../../shared/utils");
const utils_2 = require("./utils");
const viem_1 = require("viem");
// https://docs.rango.exchange/integrations
const SUPPORTED_CHAINS = {
    [_chains_1.Chains.ETHEREUM.chainId]: 'ETH',
    [_chains_1.Chains.BNB_CHAIN.chainId]: 'BNB',
    [_chains_1.Chains.POLYGON.chainId]: 'POLYGON',
    [_chains_1.Chains.FANTOM.chainId]: 'FANTOM',
    [_chains_1.Chains.ARBITRUM.chainId]: 'ARBITRUM',
    [_chains_1.Chains.CELO.chainId]: 'CELO',
    [_chains_1.Chains.OKC.chainId]: 'OKC',
    [_chains_1.Chains.MOONRIVER.chainId]: 'MOONRIVER',
    [_chains_1.Chains.MOONBEAM.chainId]: 'MOONBEAM',
    [_chains_1.Chains.OPTIMISM.chainId]: 'OPTIMISM',
    [_chains_1.Chains.GNOSIS.chainId]: 'GNOSIS',
    [_chains_1.Chains.HARMONY_SHARD_0.chainId]: 'HARMONY',
    [_chains_1.Chains.AVALANCHE.chainId]: 'AVAX_CCHAIN',
    [_chains_1.Chains.FUSE.chainId]: 'FUSE',
    [_chains_1.Chains.CRONOS.chainId]: 'CRONOS',
    [_chains_1.Chains.BOBA.chainId]: 'BOBA',
    [_chains_1.Chains.AURORA.chainId]: 'AURORA',
    [_chains_1.Chains.HECO.chainId]: 'HECO',
    [_chains_1.Chains.EVMOS.chainId]: 'EVMOS',
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: 'POLYGONZK',
    [_chains_1.Chains.BLAST.chainId]: 'BLAST',
    [_chains_1.Chains.MODE.chainId]: 'MODE',
    [_chains_1.Chains.LINEA.chainId]: 'LINEA',
    [_chains_1.Chains.SCROLL.chainId]: 'SCROLL',
};
const RANGO_METADATA = {
    name: 'Rango',
    supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmTvX3XyrFDSiDAKPJg9xFgn8DgQbp31wYWE8q7VhaR2c7',
};
class RangoQuoteSource {
    getMetadata() {
        return RANGO_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, external: { tokenData }, }, config, }) {
        const { sellToken: sellTokenDataResult, buyToken: buyTokenDataResult } = await tokenData.request();
        const chainKey = SUPPORTED_CHAINS[chainId];
        const queryParams = {
            apiKey: config.apiKey,
            from: mapToChainId(chainKey, sellToken, sellTokenDataResult),
            to: mapToChainId(chainKey, buyToken, buyTokenDataResult),
            amount: order.sellAmount.toString(),
            fromAddress: takeFrom,
            toAddress: recipient ?? takeFrom,
            disableEstimate: config.disableValidation,
            slippage: slippagePercentage,
            contractCall: config.contractCall,
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
        const url = `https://api.rango.exchange/basic/swap?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
            (0, utils_2.failed)(RANGO_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { requestId, route: { outputAmount, outputAmountMin, fee }, tx: { txTo, txData, value, gasLimit, gasPrice, approveData }, } = await response.json();
        const gasCost = BigInt(fee.find((fee) => fee.name === 'Network Fee')?.amount ?? 0);
        const estimatedGas = gasLimit ? BigInt(gasLimit) : gasCost / BigInt(gasPrice ?? 1);
        let allowanceTarget = constants_1.Addresses.ZERO_ADDRESS;
        if (approveData) {
            const { args } = (0, viem_1.decodeFunctionData)({ abi: ABI, data: approveData });
            allowanceTarget = args[0];
        }
        const tx = {
            to: txTo,
            calldata: txData,
            value: BigInt(value ?? 0),
        };
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            buyAmount: BigInt(outputAmount),
            minBuyAmount: BigInt(outputAmountMin),
            type: 'sell',
            estimatedGas,
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, allowanceTarget),
            customData: { tx, requestId },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
    isConfigAndContextValidForQuoting(config) {
        return !!config?.apiKey;
    }
    isConfigAndContextValidForTxBuilding(config) {
        return true;
    }
}
exports.RangoQuoteSource = RangoQuoteSource;
function mapToChainId(chainKey, address, metadata) {
    return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? `${chainKey}.${metadata.symbol}` : `${chainKey}.${metadata.symbol}--${address}`;
}
const ABI = (0, viem_1.parseAbi)(['function approve(address spender, uint256 value) returns (bool success)']);
//# sourceMappingURL=rango-quote-source.js.map