"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MagpieQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const viem_1 = require("viem");
const _chains_1 = require("../../../chains");
const always_valid_source_1 = require("./base/always-valid-source");
const utils_1 = require("./utils");
const utils_2 = require("../../../shared/utils");
const constants_1 = require("../../../shared/constants");
const SUPPORTED_CHAINS = {
    [_chains_1.Chains.ARBITRUM.chainId]: 'arbitrum',
    [_chains_1.Chains.AVALANCHE.chainId]: 'avalanche',
    [_chains_1.Chains.BNB_CHAIN.chainId]: 'bsc',
    [_chains_1.Chains.ETHEREUM.chainId]: 'ethereum',
    [_chains_1.Chains.POLYGON.chainId]: 'polygon',
    [_chains_1.Chains.OPTIMISM.chainId]: 'optimism',
    [_chains_1.Chains.BASE.chainId]: 'base',
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: 'polygonzk',
    [_chains_1.Chains.BLAST.chainId]: 'blast',
    [_chains_1.Chains.SCROLL.chainId]: 'scroll',
    [_chains_1.Chains.METIS_ANDROMEDA.chainId]: 'metis',
    [_chains_1.Chains.FANTOM.chainId]: 'fantom',
};
const MAGPIE_METADATA = {
    name: 'Magpie',
    supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmfR2ybY1gvctAxU5KArQ1UDXFixBY8ehgTBUBvUqY4Q4b',
};
class MagpieQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return MAGPIE_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, }, config, }) {
        const quoteQueryParams = {
            network: SUPPORTED_CHAINS[chainId],
            fromTokenAddress: mapToken(sellToken),
            toTokenAddress: mapToken(buyToken),
            sellAmount: order.sellAmount.toString(),
            slippage: slippagePercentage / 100,
            liquiditySources: config.sourceAllowlist,
        };
        const quoteQueryString = qs_1.default.stringify(quoteQueryParams, { skipNulls: true, arrayFormat: 'comma' });
        const quoteUrl = `https://api.magpiefi.xyz/aggregator/quote?${quoteQueryString}`;
        const quoteResponse = await fetchService.fetch(quoteUrl, { timeout });
        if (!quoteResponse.ok) {
            (0, utils_1.failed)(MAGPIE_METADATA, chainId, sellToken, buyToken, await quoteResponse.text());
        }
        const { id: quoteId, amountOut, targetAddress, fees } = await quoteResponse.json();
        const estimatedGasNum = fees.find((fee) => fee.type === 'gas')?.value;
        const estimatedGas = estimatedGasNum ? (0, viem_1.parseUnits)(estimatedGasNum, 9) : undefined;
        const quote = {
            sellAmount: order.sellAmount,
            buyAmount: BigInt(amountOut),
            estimatedGas,
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, targetAddress),
            customData: { quoteId, takeFrom, recipient },
        };
        return (0, utils_1.addQuoteSlippage)(quote, order.type, slippagePercentage);
    }
    async buildTx({ components: { fetchService }, request: { chainId, sellToken, buyToken, config: { timeout }, customData: { quoteId, takeFrom, recipient }, }, }) {
        const transactionQueryParams = {
            quoteId,
            toAddress: recipient ?? takeFrom,
            fromAddress: takeFrom,
            estimateGas: false,
        };
        const transactionQueryString = qs_1.default.stringify(transactionQueryParams, { skipNulls: true, arrayFormat: 'comma' });
        const transactionUrl = `https://api.magpiefi.xyz/aggregator/transaction?${transactionQueryString}`;
        const transactionResponse = await fetchService.fetch(transactionUrl, { timeout });
        if (!transactionResponse.ok) {
            (0, utils_1.failed)(MAGPIE_METADATA, chainId, sellToken, buyToken, await transactionResponse.text());
        }
        const { to, value, data } = await transactionResponse.json();
        return { to, calldata: data, value: BigInt(value) };
    }
}
exports.MagpieQuoteSource = MagpieQuoteSource;
function mapToken(address) {
    return (0, utils_2.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : address;
}
//# sourceMappingURL=magpie-quote-source.js.map