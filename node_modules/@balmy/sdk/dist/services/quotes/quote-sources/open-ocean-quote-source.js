"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenOceanQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const _chains_1 = require("../../../chains");
const viem_1 = require("viem");
const utils_1 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
const constants_1 = require("../../../shared/constants");
const utils_2 = require("../../../shared/utils");
// https://docs.openocean.finance/dev/supported-chains
const SUPPORTED_CHAINS = {
    [_chains_1.Chains.ETHEREUM.chainId]: { chainKey: 'eth' },
    [_chains_1.Chains.BNB_CHAIN.chainId]: { chainKey: 'bsc' },
    [_chains_1.Chains.POLYGON.chainId]: { chainKey: 'polygon', nativeAsset: '0x0000000000000000000000000000000000001010' },
    [_chains_1.Chains.BASE.chainId]: { chainKey: 'base' },
    [_chains_1.Chains.LINEA.chainId]: { chainKey: 'linea' },
    [_chains_1.Chains.FANTOM.chainId]: { chainKey: 'fantom', nativeAsset: '0x0000000000000000000000000000000000000000' },
    [_chains_1.Chains.AVALANCHE.chainId]: { chainKey: 'avax', nativeAsset: '0x0000000000000000000000000000000000000000' },
    [_chains_1.Chains.ARBITRUM.chainId]: { chainKey: 'arbitrum' },
    [_chains_1.Chains.OPTIMISM.chainId]: { chainKey: 'optimism' },
    [_chains_1.Chains.MOONRIVER.chainId]: { chainKey: 'moonriver' },
    [_chains_1.Chains.AURORA.chainId]: { chainKey: 'aurora' },
    [_chains_1.Chains.CRONOS.chainId]: { chainKey: 'cronos', nativeAsset: '0x0000000000000000000000000000000000000000' },
    [_chains_1.Chains.HARMONY_SHARD_0.chainId]: { chainKey: 'harmony' },
    [_chains_1.Chains.KAVA.chainId]: { chainKey: 'kava' },
    [_chains_1.Chains.METIS_ANDROMEDA.chainId]: { chainKey: 'metis', nativeAsset: '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000' },
    [_chains_1.Chains.CELO.chainId]: { chainKey: 'celo', nativeAsset: '0x471ece3750da237f93b8e339c536989b8978a438' },
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: { chainKey: 'polygon_zkevm' },
    [_chains_1.Chains.ONTOLOGY.chainId]: { chainKey: 'ontvm' },
    [_chains_1.Chains.GNOSIS.chainId]: { chainKey: 'xdai', nativeAsset: '0x0000000000000000000000000000000000000000' },
    [_chains_1.Chains.opBNB.chainId]: { chainKey: 'opbnb' },
    [_chains_1.Chains.BLAST.chainId]: { chainKey: 'blast' },
    [_chains_1.Chains.ROOTSTOCK.chainId]: { chainKey: 'rootstock' },
    [_chains_1.Chains.MODE.chainId]: { chainKey: 'mode' },
};
const OPEN_OCEAN_METADATA = {
    name: 'Open Ocean',
    supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmP7bVENjMmobmjJcPFX6VbFTmj6pKmFNqv7Qkyqui44dT',
};
class OpenOceanQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return OPEN_OCEAN_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, external, }, config, }) {
        const [{ sellToken: sellTokenDataResult }, gasPriceResult] = await Promise.all([external.tokenData.request(), external.gasPrice.request()]);
        const legacyGasPrice = eip1159ToLegacy(gasPriceResult);
        const gasPrice = parseFloat((0, viem_1.formatUnits)(legacyGasPrice, 9));
        const amount = (0, viem_1.formatUnits)(order.sellAmount, sellTokenDataResult.decimals);
        const { chainKey, nativeAsset } = SUPPORTED_CHAINS[chainId];
        const native = nativeAsset ?? constants_1.Addresses.NATIVE_TOKEN;
        const queryParams = {
            inTokenAddress: (0, utils_2.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN) ? native : sellToken,
            outTokenAddress: (0, utils_2.isSameAddress)(buyToken, constants_1.Addresses.NATIVE_TOKEN) ? native : buyToken,
            amount: amount,
            slippage: slippagePercentage,
            gasPrice: gasPrice,
            account: recipient ?? takeFrom,
            referrer: config.referrer?.address,
            enabledDexIds: config.sourceAllowlist,
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
        const url = `https://open-api.openocean.finance/v3/${chainKey}/swap_quote?${queryString}`;
        const headers = {};
        if (config.apiKey) {
            headers['apikey'] = config.apiKey;
        }
        const response = await fetchService.fetch(url, { timeout, headers });
        if (!response.ok) {
            (0, utils_1.failed)(OPEN_OCEAN_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { data: { outAmount, estimatedGas, minOutAmount, to, value, data }, } = await response.json();
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            buyAmount: BigInt(outAmount),
            minBuyAmount: BigInt(minOutAmount),
            type: 'sell',
            estimatedGas: BigInt(estimatedGas),
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, to),
            customData: {
                tx: {
                    to,
                    calldata: data,
                    value: BigInt(value ?? 0),
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.OpenOceanQuoteSource = OpenOceanQuoteSource;
function eip1159ToLegacy(gasPrice) {
    if ('gasPrice' in gasPrice) {
        return BigInt(gasPrice.gasPrice);
    }
    return BigInt(gasPrice.maxFeePerGas);
}
//# sourceMappingURL=open-ocean-quote-source.js.map