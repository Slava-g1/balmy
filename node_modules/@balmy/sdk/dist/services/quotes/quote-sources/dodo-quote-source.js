"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DodoDexQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const qs_1 = __importDefault(require("qs"));
const utils_1 = require("./utils");
const viem_1 = require("viem");
const constants_1 = require("../../../shared/constants");
const DODO_DEX_METADATA = {
    name: 'DODO',
    supports: {
        chains: [
            _chains_1.Chains.ETHEREUM.chainId,
            _chains_1.Chains.BNB_CHAIN.chainId,
            _chains_1.Chains.ARBITRUM.chainId,
            _chains_1.Chains.POLYGON.chainId,
            _chains_1.Chains.AURORA.chainId,
            _chains_1.Chains.AVALANCHE.chainId,
            _chains_1.Chains.BASE.chainId,
            _chains_1.Chains.BOBA.chainId,
            _chains_1.Chains.BASE_GOERLI.chainId,
            _chains_1.Chains.HECO.chainId,
            _chains_1.Chains.LINEA.chainId,
            _chains_1.Chains.MOONRIVER.chainId,
            _chains_1.Chains.OKC.chainId,
            _chains_1.Chains.OPTIMISM.chainId,
            _chains_1.Chains.SCROLL.chainId,
        ],
        swapAndTransfer: false,
        buyOrders: false,
    },
    logoURI: 'ipfs://Qmc5ug2FpdeDFVNif7Q48Uvx3LoAvkeU4ksNJtL3qkEdqc',
};
class DodoDexQuoteSource {
    getMetadata() {
        return DODO_DEX_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom }, config: { slippagePercentage, timeout }, }, config, }) {
        const chain = (0, _chains_1.getChainByKey)(chainId);
        if (!chain)
            throw new Error(`Chain with id ${chainId} not found`);
        const queryParams = {
            chainId,
            fromAmount: order.sellAmount,
            fromTokenAddress: sellToken,
            toTokenAddress: buyToken,
            rpc: chain.publicRPCs[0],
            slippage: slippagePercentage,
            userAddr: takeFrom,
            apikey: config.apiKey,
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
        const quoteResponse = await fetchService.fetch(`https://api.dodoex.io/route-service/developer/swap?${queryString}`, {
            headers: { 'Content-Type': 'application/json' },
            timeout,
        });
        if (!quoteResponse.ok) {
            (0, utils_1.failed)(DODO_DEX_METADATA, chainId, sellToken, buyToken, await quoteResponse.text());
        }
        const quoteResult = await quoteResponse.json();
        if (quoteResult.status < 0) {
            (0, utils_1.failed)(DODO_DEX_METADATA, chainId, sellToken, buyToken, quoteResult.data);
        }
        const buyAmount = (0, viem_1.parseUnits)(quoteResult.data.resAmount.toString(), quoteResult.data.targetDecimals);
        const { targetApproveAddr, data, to, value } = quoteResult.data;
        const quote = {
            sellAmount: order.sellAmount,
            buyAmount,
            estimatedGas: undefined,
            allowanceTarget: targetApproveAddr ?? constants_1.Addresses.ZERO_ADDRESS,
            customData: {
                tx: {
                    calldata: data,
                    to,
                    value: BigInt(value ?? 0),
                },
            },
        };
        return (0, utils_1.addQuoteSlippage)(quote, order.type, slippagePercentage);
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
    isConfigAndContextValidForQuoting(config) {
        return !!config?.apiKey;
    }
    isConfigAndContextValidForTxBuilding(config) {
        return true;
    }
}
exports.DodoDexQuoteSource = DodoDexQuoteSource;
//# sourceMappingURL=dodo-quote-source.js.map