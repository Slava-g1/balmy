"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KyberswapQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("../../../shared/utils");
const always_valid_source_1 = require("./base/always-valid-source");
const utils_2 = require("./utils");
const SUPPORTED_CHAINS = {
    [_chains_1.Chains.ARBITRUM.chainId]: 'arbitrum',
    [_chains_1.Chains.AURORA.chainId]: 'aurora',
    [_chains_1.Chains.AVALANCHE.chainId]: 'avalanche',
    [_chains_1.Chains.BNB_CHAIN.chainId]: 'bsc',
    [_chains_1.Chains.BIT_TORRENT.chainId]: 'bttc',
    [_chains_1.Chains.CRONOS.chainId]: 'cronos',
    [_chains_1.Chains.ETHEREUM.chainId]: 'ethereum',
    [_chains_1.Chains.FANTOM.chainId]: 'fantom',
    [_chains_1.Chains.OASIS_EMERALD.chainId]: 'oasis',
    [_chains_1.Chains.POLYGON.chainId]: 'polygon',
    [_chains_1.Chains.VELAS.chainId]: 'velas',
    [_chains_1.Chains.OPTIMISM.chainId]: 'optimism',
    [_chains_1.Chains.LINEA.chainId]: 'linea',
    [_chains_1.Chains.BASE.chainId]: 'base',
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: 'polygon-zkevm',
    [_chains_1.Chains.SCROLL.chainId]: 'scroll',
    [_chains_1.Chains.BLAST.chainId]: 'blast',
    [_chains_1.Chains.MANTLE.chainId]: 'mantle',
};
const KYBERSWAP_METADATA = {
    name: 'Kyberswap',
    supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmNcTVyqeVtNoyrT546VgJTD4vsZEkWp6zhDJ4qhgKkhbK',
};
class KyberswapQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return KYBERSWAP_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout, txValidFor }, }, config, }) {
        const chainKey = SUPPORTED_CHAINS[chainId];
        const headers = config.referrer?.name ? { 'x-client-id': config.referrer?.name } : undefined;
        const url = `https://aggregator-api.kyberswap.com/${chainKey}/api/v1/routes` +
            `?tokenIn=${sellToken}` +
            `&tokenOut=${buyToken}` +
            `&amountIn=${order.sellAmount.toString()}` +
            `&saveGas=0` +
            `&gasInclude=true`;
        const routeResponse = await fetchService.fetch(url, { timeout, headers });
        if (!routeResponse.ok) {
            (0, utils_2.failed)(KYBERSWAP_METADATA, chainId, sellToken, buyToken, await routeResponse.text());
        }
        const { data: { routeSummary, routerAddress }, } = await routeResponse.json();
        const quote = {
            sellAmount: order.sellAmount,
            buyAmount: BigInt(routeSummary.amountOut),
            estimatedGas: BigInt(routeSummary.gas),
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, routerAddress),
            customData: { routeSummary, slippagePercentage, txValidFor, takeFrom, recipient },
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, slippagePercentage);
    }
    async buildTx({ components: { fetchService }, request: { chainId, sellToken, buyToken, sellAmount, config: { timeout }, customData: { routeSummary, txValidFor, slippagePercentage, takeFrom, recipient }, }, config, }) {
        const chainKey = SUPPORTED_CHAINS[chainId];
        const headers = config.referrer?.name ? { 'x-client-id': config.referrer?.name } : undefined;
        const buildResponse = await fetchService.fetch(`https://aggregator-api.kyberswap.com/${chainKey}/api/v1/route/build`, {
            timeout,
            headers,
            method: 'POST',
            body: JSON.stringify({
                routeSummary,
                slippageTolerance: slippagePercentage * 100,
                recipient: recipient ?? takeFrom,
                deadline: txValidFor ? (0, utils_1.calculateDeadline)(txValidFor) : undefined,
                source: config.referrer?.name,
                sender: takeFrom,
                skipSimulateTransaction: config.disableValidation,
            }),
        });
        if (!buildResponse.ok) {
            (0, utils_2.failed)(KYBERSWAP_METADATA, chainId, sellToken, buyToken, await buildResponse.text());
        }
        const { data: { data, routerAddress }, } = await buildResponse.json();
        if (!data) {
            (0, utils_2.failed)(KYBERSWAP_METADATA, chainId, sellToken, buyToken, 'Failed to calculate a quote');
        }
        const value = (0, utils_1.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN) ? sellAmount : 0n;
        return {
            to: routerAddress,
            value,
            calldata: data,
        };
    }
}
exports.KyberswapQuoteSource = KyberswapQuoteSource;
//# sourceMappingURL=kyberswap-quote-source.js.map