"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BebopQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const _chains_1 = require("../../../chains");
const utils_1 = require("../../../shared/utils");
const utils_2 = require("./utils");
// Supported Networks: https://docs.bebop.xyz/bebop/chains-availability
const NETWORK_KEY = {
    [_chains_1.Chains.ETHEREUM.chainId]: 'ethereum',
    [_chains_1.Chains.POLYGON.chainId]: 'polygon',
    [_chains_1.Chains.ARBITRUM.chainId]: 'arbitrum',
    [_chains_1.Chains.OPTIMISM.chainId]: 'optimism',
    [_chains_1.Chains.BLAST.chainId]: 'blast',
    [_chains_1.Chains.OPTIMISM.chainId]: 'optimism',
    [_chains_1.Chains.BASE.chainId]: 'base',
    [_chains_1.Chains.BNB_CHAIN.chainId]: 'bsc',
    [_chains_1.Chains.MODE.chainId]: 'mode',
    [_chains_1.Chains.POLYGON.chainId]: 'polygon',
    [_chains_1.Chains.SCROLL.chainId]: 'scroll',
};
const BEBOP_METADATA = {
    name: 'Bebop',
    supports: {
        chains: Object.keys(NETWORK_KEY).map(Number),
        swapAndTransfer: true,
        buyOrders: true,
    },
    logoURI: 'ipfs://QmTMusok8SqDoa1MDGgZ3xohrPTnY6j2xxR5jPphBDaUDi',
};
class BebopQuoteSource {
    getMetadata() {
        return BEBOP_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom, recipient }, }, config, }) {
        const checksummedSellToken = (0, utils_2.checksum)(sellToken);
        const checksummedBuyToken = (0, utils_2.checksum)(buyToken);
        const checksummedTakerAddress = (0, utils_2.checksum)(takeFrom);
        const checksummedRecipient = recipient && (0, utils_2.checksum)(recipient);
        const queryParams = {
            sell_tokens: [checksummedSellToken],
            buy_tokens: [checksummedBuyToken],
            sell_amounts: order.type === 'sell' ? [order.sellAmount.toString()] : undefined,
            buy_amounts: order.type === 'buy' ? [order.buyAmount.toString()] : undefined,
            taker_address: checksummedTakerAddress,
            receiver_address: checksummedRecipient && !(0, utils_1.isSameAddress)(checksummedRecipient, takeFrom) ? checksummedRecipient : undefined,
            source: config.referrer?.name,
            skip_validation: config.disableValidation,
            gasless: false,
            slippage: slippagePercentage,
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
        const url = `https://api.bebop.xyz/router/${NETWORK_KEY[chainId]}/v1/quote?${queryString}`;
        const headers = { 'source-auth': config.apiKey };
        const response = await fetchService.fetch(url, { timeout, headers });
        if (!response.ok) {
            (0, utils_2.failed)(BEBOP_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const result = await response.json();
        if ('error' in result) {
            (0, utils_2.failed)(BEBOP_METADATA, chainId, sellToken, buyToken, result.error.message);
        }
        const { sellTokens: { [checksummedSellToken]: { amount: sellAmount }, }, buyTokens: { [checksummedBuyToken]: { amount: buyAmount, minimumAmount: minBuyAmount }, }, approvalTarget, expiry, tx: { to, value, data, gas }, } = result.routes[0].quote;
        return {
            sellAmount: BigInt(sellAmount),
            maxSellAmount: BigInt(sellAmount),
            buyAmount: BigInt(buyAmount),
            minBuyAmount: BigInt(minBuyAmount),
            estimatedGas: BigInt(gas),
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, approvalTarget),
            type: order.type,
            customData: {
                tx: {
                    calldata: data,
                    to,
                    value: BigInt(value ?? 0),
                },
                expiry,
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
    isConfigAndContextValidForQuoting(config) {
        return !!config?.apiKey;
    }
    isConfigAndContextValidForTxBuilding(config) {
        return true;
    }
}
exports.BebopQuoteSource = BebopQuoteSource;
//# sourceMappingURL=bebop-quote-source.js.map