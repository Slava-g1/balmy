"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZRXQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("./utils");
// Supported Networks: https://0x.org/docs/0x-swap-api/introduction#supported-networks
const SUPPORTED_CHAINS = [
    _chains_1.Chains.ETHEREUM,
    _chains_1.Chains.ARBITRUM,
    _chains_1.Chains.AVALANCHE,
    _chains_1.Chains.BASE,
    _chains_1.Chains.BLAST,
    _chains_1.Chains.BNB_CHAIN,
    _chains_1.Chains.LINEA,
    _chains_1.Chains.MANTLE,
    _chains_1.Chains.MODE,
    _chains_1.Chains.OPTIMISM,
    _chains_1.Chains.POLYGON,
    _chains_1.Chains.SCROLL,
];
const ZRX_METADATA = {
    name: '0x/Matcha',
    supports: {
        chains: SUPPORTED_CHAINS.map((chain) => chain.chainId),
        swapAndTransfer: false,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmPQY4siKEJHZGW5F4JDBrUXCBFqfpnKzPA2xDmboeuZzL',
};
class ZRXQuoteSource {
    getMetadata() {
        return ZRX_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom }, }, config, }) {
        const queryParams = {
            chainId,
            sellToken,
            buyToken,
            taker: takeFrom,
            slippageBps: slippagePercentage * 100,
            affiliateAddress: config.referrer?.address,
            sellAmount: order.sellAmount.toString(),
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
        const url = `https://api.0x.org/swap/allowance-holder/quote?${queryString}`;
        const headers = {
            '0x-api-key': config.apiKey,
            '0x-version': 'v2',
        };
        const response = await fetchService.fetch(url, { timeout, headers });
        if (!response.ok) {
            (0, utils_1.failed)(ZRX_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { transaction: { data, gas, to, value }, buyAmount, minBuyAmount, issues, } = await response.json();
        const allowanceTarget = issues?.allowance?.spender ?? constants_1.Addresses.ZERO_ADDRESS;
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            buyAmount: BigInt(buyAmount),
            minBuyAmount: BigInt(minBuyAmount),
            estimatedGas: BigInt(gas ?? 0),
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, allowanceTarget),
            customData: {
                tx: {
                    calldata: data,
                    to,
                    value: BigInt(value ?? 0),
                },
            },
            type: order.type,
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
    isConfigAndContextValidForQuoting(config) {
        return !!config?.apiKey;
    }
    isConfigAndContextValidForTxBuilding(config) {
        return true;
    }
}
exports.ZRXQuoteSource = ZRXQuoteSource;
//# sourceMappingURL=0x-quote-source.js.map