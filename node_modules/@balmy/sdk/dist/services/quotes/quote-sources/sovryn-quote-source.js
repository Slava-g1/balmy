"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SovrynQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const utils_1 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
const SOVRYN_METADATA = {
    name: 'Sovryn',
    supports: {
        chains: [_chains_1.Chains.ROOTSTOCK.chainId],
        buyOrders: false,
        swapAndTransfer: false,
    },
    logoURI: 'ipfs://QmUpdb1zxtB2kUSjR1Qs1QMFPsSeZNkL21fMzGUfdjkXQA',
};
class SovrynQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return SOVRYN_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, config: { slippagePercentage, timeout, txValidFor }, accounts: { takeFrom }, order, external, ...request }, config, }) {
        const balmyUrl = config.url ?? 'https://api.balmy.xyz';
        const url = `${balmyUrl}/v1/swap/networks/${chainId}/quotes/sovryn`;
        const body = {
            ...request,
            order: { type: 'sell', sellAmount: order.sellAmount.toString() },
            slippagePercentage,
            takerAddress: takeFrom,
            txValidFor,
            quoteTimeout: timeout,
            sourceConfig: config,
        };
        const response = await fetchService.fetch(url, {
            method: 'POST',
            body: JSON.stringify(body),
            timeout,
        });
        if (!response.ok) {
            (0, utils_1.failed)(SOVRYN_METADATA, chainId, request.sellToken, request.buyToken, await response.text());
        }
        const { sellAmount, buyAmount, maxSellAmount, minBuyAmount, estimatedGas, source: { allowanceTarget }, customData, } = await response.json();
        return {
            sellAmount: BigInt(sellAmount),
            maxSellAmount: BigInt(maxSellAmount),
            buyAmount: BigInt(buyAmount),
            minBuyAmount: BigInt(minBuyAmount),
            estimatedGas: estimatedGas ? BigInt(estimatedGas) : undefined,
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(request.sellToken, allowanceTarget),
            type: order.type,
            customData: {
                tx: {
                    ...customData.tx,
                    value: customData.tx.value ? BigInt(customData.tx.value) : undefined,
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.SovrynQuoteSource = SovrynQuoteSource;
//# sourceMappingURL=sovryn-quote-source.js.map