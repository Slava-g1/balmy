"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BarterQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const utils_1 = require("../../../shared/utils");
const constants_1 = require("../../../shared/constants");
const utils_2 = require("./utils");
const BARTER_NETWORKS = {
    [_chains_1.Chains.ETHEREUM.chainId]: 'eth',
    [_chains_1.Chains.ARBITRUM.chainId]: 'arb',
};
const BARTER_METADATA = {
    name: 'Barter',
    supports: {
        chains: [_chains_1.Chains.ETHEREUM.chainId],
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmYhY34jBV93MwZ9xYVrXbcUjg1wL9btspWVoRTQCzxNUx',
};
class BarterQuoteSource {
    getMetadata() {
        return BARTER_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout, txValidFor }, }, config, }) {
        const source = checksumAndMapIfNecessary(sellToken);
        const target = checksumAndMapIfNecessary(buyToken);
        const amount = `${order.sellAmount}`;
        const headers = { accept: 'application/json', 'Content-Type': 'application/json', Authorization: config.authHeader };
        if (config.referrer?.name) {
            headers['X-From'] = config.referrer.name;
        }
        const responseEnv = await fetchService.fetch(`https://${config.customSubdomain}.${BARTER_NETWORKS[chainId]}.barterswap.xyz/env`, {
            headers,
            timeout,
        });
        if (!responseEnv.ok) {
            (0, utils_2.failed)(BARTER_METADATA, chainId, sellToken, buyToken, await responseEnv.text());
        }
        const { defaultFilters, facadeAddress } = await responseEnv.json();
        const typeFilter = calculateTypeFilters({ config, defaultFilters });
        const responseSwapRoute = await fetchService.fetch(`https://${config.customSubdomain}.${BARTER_NETWORKS[chainId]}.barterswap.xyz/getSwapRoute`, {
            method: 'POST',
            body: JSON.stringify({ source, target, amount, typeFilter }),
            timeout,
            headers,
        });
        if (!responseSwapRoute.ok) {
            (0, utils_2.failed)(BARTER_METADATA, chainId, sellToken, buyToken, await responseSwapRoute.text());
        }
        const { outputAmount, gasEstimation } = await responseSwapRoute.json();
        const minBuyAmount = (0, utils_1.subtractPercentage)(outputAmount, slippagePercentage, 'up');
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            type: 'sell',
            buyAmount: BigInt(outputAmount),
            minBuyAmount,
            estimatedGas: BigInt(gasEstimation),
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, facadeAddress),
            customData: { typeFilter, txValidFor, recipient: recipient ?? takeFrom },
        };
    }
    async buildTx({ components: { fetchService }, request: { chainId, sellToken, buyToken, sellAmount, minBuyAmount, config: { timeout }, customData: { typeFilter, txValidFor, recipient }, }, config, }) {
        const source = checksumAndMapIfNecessary(sellToken);
        const target = checksumAndMapIfNecessary(buyToken);
        const amount = `${sellAmount}`;
        const headers = { accept: 'application/json', 'Content-Type': 'application/json', Authorization: config.authHeader };
        if (config.referrer?.name) {
            headers['X-From'] = config.referrer.name;
        }
        const bodySwap = {
            source,
            target,
            amount,
            deadline: `${(0, utils_1.calculateDeadline)(txValidFor ?? '1h')}`,
            recipient,
            targetTokenMinReturn: `${minBuyAmount}`,
            typeFilter,
        };
        const responseSwap = await fetchService.fetch(`https://${config.customSubdomain}.${BARTER_NETWORKS[chainId]}.barterswap.xyz/swap`, {
            method: 'POST',
            body: JSON.stringify(bodySwap),
            timeout,
            headers,
        });
        if (!responseSwap.ok) {
            (0, utils_2.failed)(BARTER_METADATA, chainId, sellToken, buyToken, await responseSwap.text());
        }
        const resultSwap = await responseSwap.json();
        const { data, to, value } = resultSwap;
        return {
            calldata: data,
            to,
            value: BigInt(value ?? 0),
        };
    }
    isConfigAndContextValidForQuoting(config) {
        return !!config?.authHeader && !!config?.customSubdomain;
    }
    isConfigAndContextValidForTxBuilding(config) {
        return !!config?.authHeader && !!config?.customSubdomain;
    }
}
exports.BarterQuoteSource = BarterQuoteSource;
function calculateTypeFilters({ config, defaultFilters }) {
    if (config.sourceAllowlist) {
        return config.sourceAllowlist;
    }
    else if (config.sourceDenylist) {
        const lowerDenylist = new Set(config.sourceDenylist.map((source) => source.toLowerCase()));
        return defaultFilters.filter((filter) => !lowerDenylist.has(filter.toLowerCase()));
    }
    return undefined;
}
function checksumAndMapIfNecessary(address) {
    return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : (0, utils_2.checksum)(address);
}
//# sourceMappingURL=barter-quote-source.js.map