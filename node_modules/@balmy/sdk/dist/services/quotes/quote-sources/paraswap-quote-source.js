"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParaswapQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const _chains_1 = require("../../../chains");
const utils_1 = require("../../../shared/utils");
const always_valid_source_1 = require("./base/always-valid-source");
const utils_2 = require("./utils");
const PARASWAP_METADATA = {
    name: 'Paraswap',
    supports: {
        chains: [
            _chains_1.Chains.ETHEREUM.chainId,
            _chains_1.Chains.POLYGON.chainId,
            _chains_1.Chains.BNB_CHAIN.chainId,
            _chains_1.Chains.AVALANCHE.chainId,
            _chains_1.Chains.FANTOM.chainId,
            _chains_1.Chains.ARBITRUM.chainId,
            _chains_1.Chains.OPTIMISM.chainId,
            _chains_1.Chains.POLYGON_ZKEVM.chainId,
            _chains_1.Chains.BASE.chainId,
            _chains_1.Chains.GNOSIS.chainId,
        ],
        swapAndTransfer: true,
        buyOrders: true,
    },
    logoURI: 'ipfs://QmVtj4RwZ5MMfKpbfv8qXksb5WYBJsQXkaZXLq7ipvMNW5',
};
class ParaswapQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return PARASWAP_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { timeout, slippagePercentage, txValidFor }, external, }, config, }) {
        const { sellToken: { decimals: srcDecimals }, buyToken: { decimals: destDecimals }, } = await external.tokenData.request();
        const queryParams = {
            network: chainId,
            srcToken: sellToken,
            destToken: buyToken,
            amount: order.type === 'sell' ? order.sellAmount : order.buyAmount,
            side: order.type.toUpperCase(),
            srcDecimals,
            destDecimals,
            includeDEXS: config.sourceAllowlist,
            excludeDEXS: config.sourceDenylist,
            slippage: slippagePercentage * 100,
            userAddress: takeFrom,
            receiver: takeFrom !== recipient ? recipient : undefined,
            partner: config.referrer?.name,
            partnerAddress: config.referrer?.address,
            partnerFeeBps: 0,
            deadline: (0, utils_1.calculateDeadline)(txValidFor),
            version: '6.2',
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
        const url = `https://api.paraswap.io/swap?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
            (0, utils_2.failed)(PARASWAP_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { priceRoute, txParams: { to, data, value }, } = await response.json();
        const quote = {
            sellAmount: BigInt(priceRoute.srcAmount),
            buyAmount: BigInt(priceRoute.destAmount),
            estimatedGas: BigInt(priceRoute.gasCost),
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, priceRoute.tokenTransferProxy),
            customData: {
                tx: {
                    to,
                    calldata: data,
                    value: BigInt(value ?? 0),
                },
            },
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, slippagePercentage);
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.ParaswapQuoteSource = ParaswapQuoteSource;
//# sourceMappingURL=paraswap-quote-source.js.map