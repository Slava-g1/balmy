"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OdosQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const timeouts_1 = require("../../../shared/timeouts");
const utils_1 = require("../../../shared/utils");
const utils_2 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
// Supported Networks: https://docs.odos.xyz/#future-oriented-and-scalable
const ODOS_METADATA = {
    name: 'Odos',
    supports: {
        chains: [
            _chains_1.Chains.ETHEREUM.chainId,
            _chains_1.Chains.POLYGON.chainId,
            _chains_1.Chains.ARBITRUM.chainId,
            _chains_1.Chains.OPTIMISM.chainId,
            _chains_1.Chains.AVALANCHE.chainId,
            _chains_1.Chains.BNB_CHAIN.chainId,
            _chains_1.Chains.FANTOM.chainId,
            _chains_1.Chains.BASE_GOERLI.chainId,
            _chains_1.Chains.BASE.chainId,
            _chains_1.Chains.MODE.chainId,
            _chains_1.Chains.LINEA.chainId,
            _chains_1.Chains.MANTLE.chainId,
            _chains_1.Chains.SCROLL.chainId,
        ],
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://Qma71evDJfVUSBU53qkf8eDDysUgojsZNSnFRWa4qWragz',
};
const BALMY_REFERRAL_CODE = 1533410238;
class OdosQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return ODOS_METADATA;
    }
    async quote(params) {
        // Note: Odos supports simple and advanced quotes. Simple quotes may offer worse prices, but it resolves faster. Since the advanced quote
        //       might timeout, we will make two quotes (one simple and one advanced) and we'll return the simple one if the other one timeouts
        const simpleQuote = getQuote({ ...params, simple: true });
        const advancedQuote = (0, timeouts_1.timeoutPromise)(getQuote({ ...params, simple: false }), params.request.config.timeout, { reduceBy: '100ms' });
        const [simple, advanced] = await Promise.allSettled([simpleQuote, advancedQuote]);
        if (advanced.status === 'fulfilled') {
            return advanced.value;
        }
        else if (simple.status === 'fulfilled') {
            return simple.value;
        }
        else {
            return Promise.reject(simple.reason);
        }
    }
    async buildTx({ components: { fetchService }, request: { chainId, sellToken, buyToken, config: { timeout }, customData: { pathId, userAddr, recipient }, }, }) {
        const assembleResponse = await fetchService.fetch('https://api.odos.xyz/sor/assemble', {
            body: JSON.stringify({ userAddr, pathId, receiver: recipient }),
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            timeout,
        });
        if (!assembleResponse.ok) {
            (0, utils_2.failed)(ODOS_METADATA, chainId, sellToken, buyToken, await assembleResponse.text());
        }
        const { transaction: { data, to, value }, } = await assembleResponse.json();
        return {
            to,
            calldata: data,
            value: BigInt(value),
        };
    }
}
exports.OdosQuoteSource = OdosQuoteSource;
async function getQuote({ simple, components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, }, config, }) {
    const checksummedSell = checksumAndMapIfNecessary(sellToken);
    const checksummedBuy = checksumAndMapIfNecessary(buyToken);
    const userAddr = (0, utils_2.checksum)(takeFrom);
    const quoteBody = {
        chainId,
        inputTokens: [{ tokenAddress: checksummedSell, amount: order.sellAmount.toString() }],
        outputTokens: [{ tokenAddress: checksummedBuy, proportion: 1 }],
        userAddr,
        slippageLimitPercent: slippagePercentage,
        sourceWhitelist: config?.sourceAllowlist,
        sourceBlacklist: config?.sourceDenylist,
        simulate: !config.disableValidation,
        pathViz: false,
        disableRFQs: !config?.supportRFQs, // Disable by default
        referralCode: config?.referralCode ?? BALMY_REFERRAL_CODE, // If not set, we will use Balmy's code
        simple,
    };
    const [quoteResponse, routerResponse] = await Promise.all([
        fetchService.fetch('https://api.odos.xyz/sor/quote/v2', {
            body: JSON.stringify(quoteBody),
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            timeout,
        }),
        fetchService.fetch(`https://api.odos.xyz/info/router/v2/${chainId}`, {
            headers: { 'Content-Type': 'application/json' },
            timeout,
        }),
    ]);
    if (!quoteResponse.ok) {
        (0, utils_2.failed)(ODOS_METADATA, chainId, sellToken, buyToken, await quoteResponse.text());
    }
    if (!routerResponse.ok) {
        (0, utils_2.failed)(ODOS_METADATA, chainId, sellToken, buyToken, await routerResponse.text());
    }
    const { pathId, gasEstimate, outAmounts: [outputTokenAmount], } = await quoteResponse.json();
    const { address } = await routerResponse.json();
    const quote = {
        sellAmount: order.sellAmount,
        buyAmount: BigInt(outputTokenAmount),
        estimatedGas: BigInt(gasEstimate),
        allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, address),
        customData: {
            pathId,
            userAddr,
            recipient: recipient ? (0, utils_2.checksum)(recipient) : userAddr,
        },
    };
    return (0, utils_2.addQuoteSlippage)(quote, 'sell', slippagePercentage);
}
function checksumAndMapIfNecessary(address) {
    return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : (0, utils_2.checksum)(address);
}
//# sourceMappingURL=odos-quote-source.js.map