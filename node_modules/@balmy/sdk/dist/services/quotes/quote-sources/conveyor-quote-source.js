"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConveyorQuoteSource = void 0;
const viem_1 = require("viem");
const _chains_1 = require("../../../chains");
const always_valid_source_1 = require("./base/always-valid-source");
const utils_1 = require("./utils");
const DEFAULT_REFERRERS = {
    [_chains_1.Chains.ETHEREUM.chainId]: 6,
    [_chains_1.Chains.OPTIMISM.chainId]: 4,
    [_chains_1.Chains.POLYGON.chainId]: 4,
    [_chains_1.Chains.BNB_CHAIN.chainId]: 4,
    [_chains_1.Chains.ARBITRUM.chainId]: 3,
    [_chains_1.Chains.BASE.chainId]: 4,
};
const CONVEYOR_METADATA = {
    name: 'Conveyor',
    supports: {
        chains: [
            _chains_1.Chains.ETHEREUM.chainId,
            _chains_1.Chains.BNB_CHAIN.chainId,
            _chains_1.Chains.BASE.chainId,
            _chains_1.Chains.OPTIMISM.chainId,
            _chains_1.Chains.ARBITRUM.chainId,
            _chains_1.Chains.POLYGON.chainId,
        ],
        swapAndTransfer: false,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmcuftRVxMooC2pvyBAcePW7of9JzzGArMyWFGrY6EpwCT',
};
class ConveyorQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return CONVEYOR_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom }, }, config, }) {
        let referrer = '0';
        if (config.referrerCodes !== 'disable') {
            referrer = `${config.referrerCodes?.[chainId] ?? DEFAULT_REFERRERS[chainId] ?? 0}`;
        }
        const body = {
            tokenIn: sellToken,
            tokenOut: buyToken,
            amountIn: order.sellAmount.toString(),
            slippage: slippagePercentage * 100,
            // Note: Conveyor doesn't support swap & transfer, so the recipient must be the same as the taker address
            recipient: takeFrom,
            chainId,
            referrer,
            partner: config.referrer?.name,
            forceCalldata: true,
        };
        const response = await fetchService.fetch('https://api.conveyor.finance', {
            timeout,
            method: 'POST',
            body: JSON.stringify(body),
        });
        if (!response.ok) {
            (0, utils_1.failed)(CONVEYOR_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { body: result } = await response.json();
        if ('errorStatus' in result && !config.disableValidation) {
            // We don't have a way to disable Conveyor's validation, but we can work around it. So we will only fail
            // when the validation fails, and the config didn't mark it as disabled
            (0, utils_1.failed)(CONVEYOR_METADATA, chainId, sellToken, buyToken, JSON.stringify(result.errorStatus));
        }
        if (!('tx' in result) && 'message' in result) {
            (0, utils_1.failed)(CONVEYOR_METADATA, chainId, sellToken, buyToken, result.message);
        }
        const { tx: { to, data, simulation, value }, info: { amountOut, amountOutMin, conveyorGas }, } = result;
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            buyAmount: BigInt(amountOut),
            minBuyAmount: BigInt(amountOutMin),
            estimatedGas: BigInt(conveyorGas),
            type: 'sell',
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, to),
            customData: {
                tx: {
                    calldata: (0, viem_1.isHex)(data) ? data : simulation.data,
                    to,
                    value: BigInt(value ?? 0),
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.ConveyorQuoteSource = ConveyorQuoteSource;
//# sourceMappingURL=conveyor-quote-source.js.map