"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwingQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
const viem_1 = require("viem");
const utils_2 = require("../../../shared/utils");
// Supported Networks: https://platform.swing.xyz/api/v1/chains
const SUPPORTED_CHAINS = {
    [_chains_1.Chains.ARBITRUM.chainId]: 'arbitrum',
    [_chains_1.Chains.AVALANCHE.chainId]: 'avalanche',
    [_chains_1.Chains.BASE.chainId]: 'base',
    [_chains_1.Chains.BNB_CHAIN.chainId]: 'bsc',
    [_chains_1.Chains.BLAST.chainId]: 'blast',
    [_chains_1.Chains.CELO.chainId]: 'celo',
    [_chains_1.Chains.ETHEREUM.chainId]: 'ethereum',
    [_chains_1.Chains.FANTOM.chainId]: 'fantom',
    [_chains_1.Chains.GNOSIS.chainId]: 'gnosis',
    [_chains_1.Chains.LINEA.chainId]: 'linea',
    [_chains_1.Chains.MANTLE.chainId]: 'mantle',
    [_chains_1.Chains.METIS_ANDROMEDA.chainId]: 'metis',
    [_chains_1.Chains.MODE.chainId]: 'mode',
    [_chains_1.Chains.MOONBEAM.chainId]: 'moonbeam',
    [_chains_1.Chains.OPTIMISM.chainId]: 'optimism',
    [_chains_1.Chains.POLYGON.chainId]: 'polygon',
    [_chains_1.Chains.ROOTSTOCK.chainId]: 'rootstock',
    [_chains_1.Chains.SCROLL.chainId]: 'scroll',
};
const SWING_METADATA = {
    name: 'Swing',
    supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmNjjXnWeWSsn9fbTFNCs9CA3WneQU27NfTJgoZ4kBqCUv',
};
class SwingQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return SWING_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom, recipient }, external: { tokenData }, }, config, }) {
        const { sellToken: sellTokenDataResult, buyToken: buyTokenDataResult } = await tokenData.request();
        const chainKey = SUPPORTED_CHAINS[chainId];
        const projectId = config?.projectId ?? 'balmy';
        const quoteQueryParams = {
            fromChain: chainKey,
            fromTokenAddress: sellToken,
            tokenSymbol: sellTokenDataResult.symbol,
            fromUserAddress: takeFrom,
            toChain: chainKey,
            toTokenAddress: buyToken,
            toTokenSymbol: buyTokenDataResult.symbol,
            toUserAddress: recipient ?? takeFrom,
            tokenAmount: order.sellAmount.toString(),
            maxSlippage: slippagePercentage / 100,
            skipValidation: config.disableValidation,
            projectId,
        };
        const quoteQueryString = qs_1.default.stringify(quoteQueryParams, { skipNulls: true, arrayFormat: 'comma' });
        const quoteUrl = `https://swap.prod.swing.xyz/v0/transfer/quote?${quoteQueryString}`;
        const quoteResponse = await fetchService.fetch(quoteUrl, { timeout });
        if (!quoteResponse.ok) {
            (0, utils_1.failed)(SWING_METADATA, chainId, sellToken, buyToken, await quoteResponse.text());
        }
        const { routes } = await quoteResponse.json();
        if (routes.length === 0) {
            throw new Error('No routes found');
        }
        const route = routes[0];
        const { quote: { amount: buyAmount, integration }, gas, } = route;
        let allowanceTarget = constants_1.Addresses.ZERO_ADDRESS;
        if (!(0, utils_2.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN)) {
            const approvalQueryParams = {
                fromChain: chainKey,
                fromAddress: takeFrom,
                tokenAddress: sellToken,
                tokenSymbol: sellTokenDataResult.symbol,
                toTokenAddress: buyToken,
                toTokenSymbol: buyTokenDataResult.symbol,
                toChain: chainKey,
                tokenAmount: order.sellAmount.toString(),
                projectId,
                bridge: integration,
            };
            const approvalQueryString = qs_1.default.stringify(approvalQueryParams, { skipNulls: true, arrayFormat: 'comma' });
            const approvalUrl = `https://swap.prod.swing.xyz/v0/transfer/approve?${approvalQueryString}`;
            const approvalResponse = await fetchService.fetch(approvalUrl, { timeout });
            if (!approvalResponse.ok) {
                (0, utils_1.failed)(SWING_METADATA, chainId, sellToken, buyToken, await approvalResponse.text());
            }
            const { tx: [{ data }], } = await approvalResponse.json();
            const { args } = (0, viem_1.decodeFunctionData)({ abi: ABI, data });
            allowanceTarget = args[0];
        }
        const quote = {
            sellAmount: BigInt(order.sellAmount),
            buyAmount: BigInt(buyAmount),
            allowanceTarget,
            estimatedGas: gas != '0' ? BigInt(gas) : undefined,
            customData: {
                chainKey,
                fromUserAddress: takeFrom,
                toUserAddress: recipient ?? takeFrom,
                tokenSymbol: sellTokenDataResult.symbol,
                fromTokenAddress: sellToken,
                toTokenSymbol: buyTokenDataResult.symbol,
                toTokenAddress: buyToken,
                tokenAmount: order.sellAmount.toString(),
                maxSlippage: slippagePercentage / 100,
                route: route.route,
                projectId,
            },
        };
        return (0, utils_1.addQuoteSlippage)(quote, order.type, slippagePercentage);
    }
    async buildTx({ request: { chainId, sellToken, buyToken, customData, config: { timeout }, }, components: { fetchService }, config, }) {
        const sendParams = {
            ...customData,
            fromChain: customData.chainKey,
            toChain: customData.chainKey,
            skipValidation: config.disableValidation,
        };
        const sendResponse = await fetchService.fetch('https://swap.prod.swing.xyz/v0/transfer/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(sendParams),
            timeout,
        });
        if (!sendResponse.ok) {
            (0, utils_1.failed)(SWING_METADATA, chainId, sellToken, buyToken, await sendResponse.text());
        }
        const { tx: { data, to, value }, } = await sendResponse.json();
        return { calldata: data, to, value: value ? BigInt(value) : undefined };
    }
}
exports.SwingQuoteSource = SwingQuoteSource;
const ABI = (0, viem_1.parseAbi)(['function approve(address spender, uint256 value) returns (bool success)']);
//# sourceMappingURL=swing-quote-source.js.map