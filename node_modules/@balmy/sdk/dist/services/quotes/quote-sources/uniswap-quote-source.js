"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniswapQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("../../../shared/utils");
const utils_2 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
const viem_1 = require("viem");
const ROUTER_ADDRESS = {
    [_chains_1.Chains.ETHEREUM.chainId]: '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    [_chains_1.Chains.OPTIMISM.chainId]: '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    [_chains_1.Chains.POLYGON.chainId]: '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    [_chains_1.Chains.ARBITRUM.chainId]: '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    [_chains_1.Chains.CELO.chainId]: '0x5615CDAb10dc425a742d643d949a7F474C01abc4',
    [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    [_chains_1.Chains.POLYGON_MUMBAI.chainId]: '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    [_chains_1.Chains.BNB_CHAIN.chainId]: '0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2',
    [_chains_1.Chains.BASE.chainId]: '0x2626664c2603336E57B271c5C0b26F421741e481',
    [_chains_1.Chains.AVALANCHE.chainId]: '0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE',
};
const UNISWAP_METADATA = {
    name: 'Uniswap',
    supports: {
        chains: Object.keys(ROUTER_ADDRESS).map(Number),
        swapAndTransfer: true,
        buyOrders: true,
    },
    logoURI: 'ipfs://QmNa3YBYAYS5qSCLuXataV5XCbtxP9ZB4rHUfomRxrpRhJ',
};
class UniswapQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return UNISWAP_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, config: { slippagePercentage, timeout, txValidFor }, accounts: { takeFrom, recipient }, }, }) {
        const amount = order.type === 'sell' ? order.sellAmount : order.buyAmount;
        const isSellTokenNativeToken = (0, utils_1.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN);
        const isBuyTokenNativeToken = (0, utils_1.isSameAddress)(buyToken, constants_1.Addresses.NATIVE_TOKEN);
        if (isSellTokenNativeToken && order.type === 'buy') {
            // We do this because it's very hard and expensive to wrap native to wToken, spend only
            // some of it and then return the extra native token to the caller
            throw new Error(`Uniswap does not support buy orders with native token`);
        }
        const router = ROUTER_ADDRESS[chainId];
        recipient = recipient ?? takeFrom;
        const url = 'https://api.uniswap.org/v1/quote' +
            '?protocols=v2,v3,mixed' +
            `&tokenInAddress=${mapToWTokenIfNecessary(chainId, sellToken)}` +
            `&tokenInChainId=${chainId}` +
            `&tokenOutAddress=${mapToWTokenIfNecessary(chainId, buyToken)}` +
            `&tokenOutChainId=${chainId}` +
            `&amount=${amount.toString()}` +
            `&type=${order.type === 'sell' ? 'exactIn' : 'exactOut'}` +
            `&recipient=${isBuyTokenNativeToken ? router : recipient}` +
            `&deadline=${(0, utils_1.timeToSeconds)(txValidFor ?? '3h')}` +
            `&slippageTolerance=${slippagePercentage}`;
        // These are needed so that the API allows us to make the call
        const headers = {
            origin: 'https://app.uniswap.org',
            referer: 'https://app.uniswap.org/',
        };
        const response = await fetchService.fetch(url, { headers, timeout });
        if (!response.ok) {
            (0, utils_2.failed)(UNISWAP_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        let { quote: quoteAmount, methodParameters: { calldata }, gasUseEstimate, } = await response.json();
        const sellAmount = order.type === 'sell' ? order.sellAmount : BigInt(quoteAmount);
        const buyAmount = order.type === 'sell' ? BigInt(quoteAmount) : order.buyAmount;
        const value = isSellTokenNativeToken ? sellAmount : undefined;
        if (isBuyTokenNativeToken) {
            // Use multicall to unwrap wToken
            const minBuyAmount = calculateMinBuyAmount(order.type, buyAmount, slippagePercentage);
            const unwrapData = (0, viem_1.encodeFunctionData)({
                abi: ROUTER_ABI,
                functionName: 'unwrapWETH9',
                args: [minBuyAmount, recipient],
            });
            const multicallData = (0, viem_1.encodeFunctionData)({
                abi: ROUTER_ABI,
                functionName: 'multicall',
                args: [[calldata, unwrapData]],
            });
            // Update calldata and gas estimate
            calldata = multicallData;
            gasUseEstimate = BigInt(gasUseEstimate) + 12500n;
        }
        const quote = {
            sellAmount,
            buyAmount,
            estimatedGas: BigInt(gasUseEstimate),
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, router),
            customData: {
                tx: {
                    to: router,
                    calldata,
                    value,
                },
            },
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, slippagePercentage);
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.UniswapQuoteSource = UniswapQuoteSource;
function calculateMinBuyAmount(type, buyAmount, slippagePercentage) {
    return type === 'sell' ? BigInt((0, utils_1.subtractPercentage)(buyAmount, slippagePercentage, 'up')) : buyAmount;
}
function mapToWTokenIfNecessary(chainId, address) {
    const chain = (0, _chains_1.getChainByKey)(chainId);
    return chain && (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? chain.wToken : address;
}
const ROUTER_HUMAN_READABLE_ABI = [
    'function unwrapWETH9(uint256 amountMinimum, address recipient) payable',
    'function multicall(bytes[] data) payable returns (bytes[] memory results)',
];
const ROUTER_ABI = (0, viem_1.parseAbi)(ROUTER_HUMAN_READABLE_ABI);
//# sourceMappingURL=uniswap-quote-source.js.map