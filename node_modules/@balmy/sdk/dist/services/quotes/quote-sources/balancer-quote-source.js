"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalancerQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const utils_1 = require("./utils");
const viem_1 = require("viem");
const always_valid_source_1 = require("./base/always-valid-source");
const SUPPORTED_CHAINS = {
    [_chains_1.Chains.ARBITRUM.chainId]: 'ARBITRUM',
    [_chains_1.Chains.AVALANCHE.chainId]: 'AVALANCHE',
    [_chains_1.Chains.BASE.chainId]: 'BASE',
    [_chains_1.Chains.FANTOM.chainId]: 'FANTOM',
    [_chains_1.Chains.GNOSIS.chainId]: 'GNOSIS',
    [_chains_1.Chains.ETHEREUM.chainId]: 'MAINNET',
    [_chains_1.Chains.POLYGON.chainId]: 'POLYGON',
    [_chains_1.Chains.OPTIMISM.chainId]: 'OPTIMISM',
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: 'ZKEVM',
    [_chains_1.Chains.ETHEREUM_SEPOLIA.chainId]: 'SEPOLIA',
};
const BALANCER_METADATA = {
    name: 'Balancer',
    supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: false,
        buyOrders: true,
    },
    logoURI: 'ipfs://QmSb9Lr6Jgi9Y3RUuShfWcuCaa9EYxpyZWgBTe8GbvsUL7',
};
class BalancerQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return BALANCER_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom }, config: { slippagePercentage }, external, }, config, }) {
        const { sellToken: sellTokenDataResult, buyToken: buyTokenDataResult } = await external.tokenData.request();
        const amount = order.type == 'sell'
            ? (0, viem_1.formatUnits)(order.sellAmount, sellTokenDataResult.decimals)
            : (0, viem_1.formatUnits)(order.buyAmount, buyTokenDataResult.decimals);
        const query = {
            query: `query {
        sorGetSwapPaths( 
          chain: ${SUPPORTED_CHAINS[chainId]}
          swapAmount: "${amount}"
          swapType: ${order.type == 'sell' ? 'EXACT_IN' : 'EXACT_OUT'}
          tokenIn: "${sellToken}"
          tokenOut: "${buyToken}"
          queryBatchSwap: true
          callDataInput: {sender: "${takeFrom}", receiver: "${takeFrom}", slippagePercentage: "${slippagePercentage}"}
        ) {
          tokenInAmount
          tokenOutAmount
          callData {
            value
            to
            maxAmountInRaw
            minAmountOutRaw
            callData
          }
        }
      }`,
        };
        const quoteResponse = await fetchService.fetch(`https://api-v3.balancer.fi/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(query),
        });
        if (!quoteResponse.ok) {
            (0, utils_1.failed)(BALANCER_METADATA, chainId, sellToken, buyToken, await quoteResponse.text());
        }
        const quoteResult = await quoteResponse.json();
        if (!quoteResult.data.sorGetSwapPaths.callData) {
            (0, utils_1.failed)(BALANCER_METADATA, chainId, sellToken, buyToken, quoteResult);
        }
        const { callData: { callData: data, to, value, minAmountOutRaw, maxAmountInRaw }, tokenInAmount, tokenOutAmount, } = quoteResult.data.sorGetSwapPaths;
        const allowanceAddress = (0, utils_1.calculateAllowanceTarget)(sellToken, to);
        const minBuyAmount = order.type === 'sell' ? BigInt(minAmountOutRaw) : BigInt(tokenOutAmount);
        const maxSellAmount = order.type === 'sell' ? BigInt(tokenInAmount) : BigInt(maxAmountInRaw);
        return {
            sellAmount: BigInt(tokenInAmount),
            buyAmount: BigInt(tokenOutAmount),
            estimatedGas: undefined,
            minBuyAmount,
            maxSellAmount,
            allowanceTarget: allowanceAddress,
            type: order.type,
            customData: {
                tx: {
                    calldata: data,
                    to,
                    value: BigInt(value ?? 0),
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.BalancerQuoteSource = BalancerQuoteSource;
//# sourceMappingURL=balancer-quote-source.js.map