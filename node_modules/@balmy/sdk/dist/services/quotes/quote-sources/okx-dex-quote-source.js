"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OKXDexQuoteSource = void 0;
const qs_1 = __importDefault(require("qs"));
const crypto_js_1 = __importDefault(require("crypto-js"));
const _chains_1 = require("../../../chains");
const utils_1 = require("./utils");
const constants_1 = require("../../../shared/constants");
const utils_2 = require("../../../shared/utils");
// https://www.okx.com/web3/build/docs/waas/okx-waas-supported-networks
const SUPPORTED_CHAINS = [
    _chains_1.Chains.ETHEREUM,
    _chains_1.Chains.OPTIMISM,
    _chains_1.Chains.POLYGON,
    _chains_1.Chains.BNB_CHAIN,
    _chains_1.Chains.OKC,
    _chains_1.Chains.AVALANCHE,
    _chains_1.Chains.FANTOM,
    _chains_1.Chains.ARBITRUM,
    _chains_1.Chains.LINEA,
    _chains_1.Chains.BASE,
    _chains_1.Chains.SCROLL,
    _chains_1.Chains.BLAST,
    _chains_1.Chains.POLYGON_ZKEVM,
    _chains_1.Chains.FANTOM,
    _chains_1.Chains.MANTLE,
    _chains_1.Chains.METIS_ANDROMEDA,
];
const OKX_DEX_METADATA = {
    name: 'OKX Dex',
    supports: {
        chains: SUPPORTED_CHAINS.map(({ chainId }) => chainId),
        swapAndTransfer: false,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmarS9mPPLegvNaazZ8Kqg1gLvkbsvQE2tkdF6uZCvBrFn',
};
class OKXDexQuoteSource {
    getMetadata() {
        return OKX_DEX_METADATA;
    }
    async quote({ components, request, config }) {
        const [approvalTargetResponse, quoteResponse] = await Promise.all([
            calculateApprovalTarget({ components, request, config }),
            calculateQuote({ components, request, config }),
        ]);
        const { data: [{ routerResult: { toTokenAmount }, tx: { minReceiveAmount, to, value, data, gas }, },], } = quoteResponse;
        const { data: [{ dexContractAddress: approvalTarget }], } = approvalTargetResponse;
        return {
            sellAmount: request.order.sellAmount,
            maxSellAmount: request.order.sellAmount,
            buyAmount: BigInt(toTokenAmount),
            minBuyAmount: BigInt(minReceiveAmount),
            estimatedGas: BigInt(gas),
            allowanceTarget: approvalTarget,
            type: 'sell',
            customData: {
                tx: {
                    calldata: data,
                    to,
                    value: BigInt(value ?? 0),
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
    isConfigAndContextValidForQuoting(config) {
        return !!config?.apiKey && !!config?.passphrase && !!config?.secretKey;
    }
    isConfigAndContextValidForTxBuilding(config) {
        return true;
    }
}
exports.OKXDexQuoteSource = OKXDexQuoteSource;
async function calculateApprovalTarget({ components: { fetchService }, request: { chainId, sellToken, buyToken, config: { timeout }, }, config, }) {
    if ((0, utils_2.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN)) {
        return { data: [{ dexContractAddress: constants_1.Addresses.ZERO_ADDRESS }] };
    }
    const queryParams = {
        chainId,
        tokenContractAddress: sellToken,
        approveAmount: constants_1.Uint.MAX_256,
    };
    const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
    const path = `/api/v5/dex/aggregator/approve-transaction?${queryString}`;
    return fetch({
        sellToken,
        buyToken,
        chainId,
        path,
        timeout,
        config,
        fetchService,
    });
}
async function calculateQuote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom }, }, config, }) {
    const queryParams = {
        chainId,
        amount: order.sellAmount.toString(),
        fromTokenAddress: sellToken,
        toTokenAddress: buyToken,
        slippage: slippagePercentage / 100,
        userWalletAddress: takeFrom,
        referrerAddress: config.referrer?.address,
        feePercent: config.referrer?.address ? 0 : undefined,
    };
    const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: 'comma' });
    const path = `/api/v5/dex/aggregator/swap?${queryString}`;
    return fetch({
        sellToken,
        buyToken,
        chainId,
        path,
        timeout,
        config,
        fetchService,
    });
}
async function fetch({ sellToken, buyToken, chainId, path, fetchService, config, timeout, }) {
    const timestamp = new Date().toISOString();
    const toHash = timestamp + 'GET' + path;
    const signed = crypto_js_1.default.HmacSHA256(toHash, config.secretKey);
    const base64 = signed.toString(crypto_js_1.default.enc.Base64);
    const headers = {
        ['OK-ACCESS-KEY']: config.apiKey,
        ['OK-ACCESS-PASSPHRASE']: config.passphrase,
        ['OK-ACCESS-TIMESTAMP']: timestamp,
        ['OK-ACCESS-SIGN']: base64,
    };
    const url = `https://www.okx.com${path}`;
    const response = await fetchService.fetch(url, { timeout, headers });
    if (!response.ok) {
        (0, utils_1.failed)(OKX_DEX_METADATA, chainId, sellToken, buyToken, await response.text());
    }
    return response.json();
}
//# sourceMappingURL=okx-dex-quote-source.js.map