"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiFiQuoteSource = void 0;
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("../../../shared/utils");
const always_valid_source_1 = require("./base/always-valid-source");
const utils_2 = require("./utils");
// Supported networks: https://li.quest/v1/chains
const LI_FI_METADATA = {
    name: 'LI.FI',
    supports: {
        chains: [
            _chains_1.Chains.ETHEREUM.chainId,
            _chains_1.Chains.POLYGON.chainId,
            _chains_1.Chains.BNB_CHAIN.chainId,
            _chains_1.Chains.GNOSIS.chainId,
            _chains_1.Chains.FANTOM.chainId,
            _chains_1.Chains.OKC.chainId,
            _chains_1.Chains.AVALANCHE.chainId,
            _chains_1.Chains.ARBITRUM.chainId,
            _chains_1.Chains.OPTIMISM.chainId,
            _chains_1.Chains.MOONRIVER.chainId,
            _chains_1.Chains.MOONBEAM.chainId,
            _chains_1.Chains.CELO.chainId,
            _chains_1.Chains.FUSE.chainId,
            _chains_1.Chains.CRONOS.chainId,
            _chains_1.Chains.VELAS.chainId,
            _chains_1.Chains.AURORA.chainId,
            _chains_1.Chains.EVMOS.chainId,
            _chains_1.Chains.POLYGON_ZKEVM.chainId,
            _chains_1.Chains.BASE.chainId,
            _chains_1.Chains.ROOTSTOCK.chainId,
            _chains_1.Chains.MODE.chainId,
            _chains_1.Chains.LINEA.chainId,
            _chains_1.Chains.BOBA.chainId,
            _chains_1.Chains.METIS_ANDROMEDA.chainId,
            _chains_1.Chains.SCROLL.chainId,
            _chains_1.Chains.BLAST.chainId,
            _chains_1.Chains.MANTLE.chainId,
        ],
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmUgcnaNxsgQdjBjytxvXfeSfsDryh9bF4mNaz1Bp5QwJ4',
};
class LiFiQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return LI_FI_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, }, config, }) {
        const mappedSellToken = mapNativeToken(sellToken);
        const mappedBuyToken = mapNativeToken(buyToken);
        let url = `https://li.quest/v1/quote` +
            `?fromChain=${chainId}` +
            `&toChain=${chainId}` +
            `&fromToken=${mappedSellToken}` +
            `&toToken=${mappedBuyToken}` +
            `&fromAddress=${takeFrom}` +
            `&toAddress=${recipient ?? takeFrom}` +
            `&fromAmount=${order.sellAmount.toString()}` +
            `&slippage=${slippagePercentage / 100}`;
        if (config.referrer) {
            url += `&integrator=${config.referrer.name}`;
            url += `&referrer=${config.referrer.address}`;
        }
        const headers = {};
        if (config.apiKey) {
            headers['x-lifi-api-key'] = config.apiKey;
        }
        const response = await fetchService.fetch(url, { timeout, headers });
        if (!response.ok) {
            (0, utils_2.failed)(LI_FI_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { estimate: { approvalAddress, toAmountMin, toAmount, gasCosts }, transactionRequest: { to, data, value }, } = await response.json();
        const estimatedGas = gasCosts.reduce((accum, { estimate }) => accum + BigInt(estimate), 0n);
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            buyAmount: BigInt(toAmount),
            minBuyAmount: BigInt(toAmountMin),
            type: 'sell',
            estimatedGas,
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, approvalAddress),
            customData: {
                tx: {
                    to,
                    calldata: data,
                    value: BigInt(value ?? 0),
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.LiFiQuoteSource = LiFiQuoteSource;
function mapNativeToken(address) {
    return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : address;
}
//# sourceMappingURL=li-fi-quote-source.js.map