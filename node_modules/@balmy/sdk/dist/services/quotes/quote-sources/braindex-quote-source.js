"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrainDexQuoteSource = void 0;
const viem_1 = require("viem");
const _chains_1 = require("../../../chains");
const utils_1 = require("../../../shared/utils");
const constants_1 = require("../../../shared/constants");
const utils_2 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
const ROUTER_ADDRESS = {
    [_chains_1.Chains.MOONBEAM.chainId]: '0x415f895a14d47f951f33adc1d2fc1db0191481be',
    [_chains_1.Chains.MOONRIVER.chainId]: '0xf1a3969e1606dff178e99eaab4e90f2b41495b58',
};
const BRAINDEX_METADATA = {
    name: 'BrainDex',
    supports: {
        chains: Object.keys(ROUTER_ADDRESS).map(Number),
        swapAndTransfer: true,
        buyOrders: false,
    },
    logoURI: 'ipfs://QmYKCxMEdy7BhAokmnarPf9fE2zuyWnXK5bNUcGWRC9c87',
};
class BrainDexQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return BRAINDEX_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout, txValidFor }, }, }) {
        const mappedSellToken = mapToken(sellToken, chainId);
        const mappedBuyToken = mapToken(buyToken, chainId);
        if ((0, utils_1.isSameAddress)(mappedSellToken, mappedBuyToken))
            throw new Error(`Not supported`);
        const body = {
            chain_id: chainId,
            amount_in: (0, viem_1.toHex)(order.sellAmount),
            token_in: mappedSellToken,
            token_out: mappedBuyToken,
            // These values were copied from BrainDex's UI
            max_hops: 3,
            min_splits: 0,
            max_splits: 2,
            count: 5,
        };
        const response = await fetchService.fetch('https://api.braindex.io/api/split_route/multi', {
            method: 'POST',
            body: JSON.stringify(body),
            headers: { 'Content-Type': 'application/json' },
            timeout,
        });
        if (!response.ok) {
            (0, utils_2.failed)(BRAINDEX_METADATA, chainId, sellToken, buyToken, await response.text());
        }
        const { amount_out, swap_paths } = await response.json();
        const router = ROUTER_ADDRESS[chainId];
        const buyAmount = BigInt(amount_out);
        const minBuyAmount = (0, utils_1.subtractPercentage)(buyAmount, slippagePercentage, 'up');
        return {
            sellAmount: order.sellAmount,
            maxSellAmount: order.sellAmount,
            buyAmount,
            minBuyAmount,
            type: 'sell',
            allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, router),
            customData: { swapPaths: swap_paths, txValidFor, recipient: recipient ?? takeFrom },
        };
    }
    async buildTx({ request: { chainId, sellToken, buyToken, sellAmount, minBuyAmount, customData: { swapPaths, txValidFor, recipient }, }, }) {
        const mappedSellToken = mapToken(sellToken, chainId);
        const mappedBuyToken = mapToken(buyToken, chainId);
        const deadline = BigInt((0, utils_1.calculateDeadline)(txValidFor) ?? constants_1.Uint.MAX_256);
        let calldata;
        let value = 0n;
        if ((0, utils_1.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN)) {
            calldata = (0, viem_1.encodeFunctionData)({
                abi: ROUTER_ABI,
                functionName: 'multiSwapEthForTokens',
                args: [mappedBuyToken, recipient, minBuyAmount, deadline, swapPaths],
            });
            value = sellAmount;
        }
        else if ((0, utils_1.isSameAddress)(buyToken, constants_1.Addresses.NATIVE_TOKEN)) {
            calldata = (0, viem_1.encodeFunctionData)({
                abi: ROUTER_ABI,
                functionName: 'multiSwapTokensForEth',
                args: [mappedSellToken, recipient, sellAmount, minBuyAmount, deadline, swapPaths],
            });
        }
        else {
            calldata = (0, viem_1.encodeFunctionData)({
                abi: ROUTER_ABI,
                functionName: 'multiSwapTokensForTokens',
                args: [mappedSellToken, mappedBuyToken, recipient, sellAmount, minBuyAmount, deadline, swapPaths],
            });
        }
        return {
            to: ROUTER_ADDRESS[chainId],
            calldata,
            value,
        };
    }
}
exports.BrainDexQuoteSource = BrainDexQuoteSource;
function mapToken(token, chainId) {
    const chain = (0, _chains_1.getChainByKey)(chainId);
    return chain && (0, utils_1.isSameAddress)(token, constants_1.Addresses.NATIVE_TOKEN) ? (0, utils_2.checksum)(chain.wToken) : (0, utils_2.checksum)(token);
}
const ROUTER_ABI = [
    {
        inputs: [
            { internalType: 'address', name: 'tokenOut', type: 'address' },
            { internalType: 'address', name: 'to', type: 'address' },
            { internalType: 'uint256', name: 'amountOutMin', type: 'uint256' },
            { internalType: 'uint256', name: 'deadline', type: 'uint256' },
            { internalType: 'bytes', name: 'swapData', type: 'bytes' },
        ],
        name: 'multiSwapEthForTokens',
        outputs: [],
        stateMutability: 'payable',
        type: 'function',
    },
    {
        inputs: [
            { internalType: 'address', name: 'tokenIn', type: 'address' },
            { internalType: 'address', name: 'to', type: 'address' },
            { internalType: 'uint256', name: 'amountIn', type: 'uint256' },
            { internalType: 'uint256', name: 'amountOutMin', type: 'uint256' },
            { internalType: 'uint256', name: 'deadline', type: 'uint256' },
            { internalType: 'bytes', name: 'swapData', type: 'bytes' },
        ],
        name: 'multiSwapTokensForEth',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            { internalType: 'address', name: 'tokenIn', type: 'address' },
            { internalType: 'address', name: 'tokenOut', type: 'address' },
            { internalType: 'address', name: 'to', type: 'address' },
            { internalType: 'uint256', name: 'amountIn', type: 'uint256' },
            { internalType: 'uint256', name: 'amountOutMin', type: 'uint256' },
            { internalType: 'uint256', name: 'deadline', type: 'uint256' },
            { internalType: 'bytes', name: 'swapData', type: 'bytes' },
        ],
        name: 'multiSwapTokensForTokens',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];
//# sourceMappingURL=braindex-quote-source.js.map