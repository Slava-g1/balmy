"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalmyQuoteSource = exports.BALMY_SUPPORTED_CHAINS = void 0;
const _chains_1 = require("../../../chains");
const utils_1 = require("./utils");
const always_valid_source_1 = require("./base/always-valid-source");
exports.BALMY_SUPPORTED_CHAINS = [
    _chains_1.Chains.ETHEREUM,
    _chains_1.Chains.OPTIMISM,
    _chains_1.Chains.POLYGON,
    _chains_1.Chains.BNB_CHAIN,
    _chains_1.Chains.ARBITRUM,
    _chains_1.Chains.GNOSIS,
    _chains_1.Chains.BASE,
    _chains_1.Chains.MOONBEAM,
    _chains_1.Chains.ROOTSTOCK,
    _chains_1.Chains.AVALANCHE,
    _chains_1.Chains.BASE,
].map(({ chainId }) => chainId);
const BALMY_METADATA = {
    name: 'Balmy',
    supports: {
        chains: exports.BALMY_SUPPORTED_CHAINS,
        buyOrders: true,
        swapAndTransfer: true,
    },
    logoURI: 'ipfs://QmU3GnALKonFNwkv42LWNoXdquFskWXPAiq6sYH7DKQPGJ',
};
class BalmyQuoteSource extends always_valid_source_1.AlwaysValidConfigAndContextSource {
    getMetadata() {
        return BALMY_METADATA;
    }
    async quote({ components: { fetchService }, request: { chainId, config: { slippagePercentage, timeout, txValidFor }, accounts: { takeFrom, recipient }, order, external, ...request }, config, }) {
        const balmyUrl = config.url ?? 'https://api.balmy.xyz';
        const url = `${balmyUrl}/v1/swap/networks/${chainId}/quotes/balmy`;
        const stringOrder = order.type === 'sell' ? { type: 'sell', sellAmount: order.sellAmount.toString() } : { type: 'buy', buyAmount: order.buyAmount.toString() };
        const body = {
            ...request,
            order: stringOrder,
            slippagePercentage,
            takerAddress: takeFrom,
            recipient,
            txValidFor,
            quoteTimeout: timeout,
            sourceConfig: config,
        };
        const response = await fetchService.fetch(url, {
            method: 'POST',
            body: JSON.stringify(body),
            timeout,
        });
        if (!response.ok) {
            (0, utils_1.failed)(BALMY_METADATA, chainId, request.sellToken, request.buyToken, await response.text());
        }
        const { sellAmount, buyAmount, maxSellAmount, minBuyAmount, estimatedGas, source: { allowanceTarget }, customData, } = await response.json();
        return {
            sellAmount: BigInt(sellAmount),
            maxSellAmount: BigInt(maxSellAmount),
            buyAmount: BigInt(buyAmount),
            minBuyAmount: BigInt(minBuyAmount),
            estimatedGas: estimatedGas ? BigInt(estimatedGas) : undefined,
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(request.sellToken, allowanceTarget),
            type: order.type,
            customData: {
                tx: {
                    ...customData.tx,
                    value: customData.tx.value ? BigInt(customData.tx.value) : undefined,
                },
            },
        };
    }
    async buildTx({ request }) {
        return request.customData.tx;
    }
}
exports.BalmyQuoteSource = BalmyQuoteSource;
//# sourceMappingURL=balmy-quote-source.js.map