"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleResponseFailure = exports.calculateGasDetails = exports.QuoteService = void 0;
const quote_compare_1 = require("./quote-compare");
const _chains_1 = require("../../chains");
const utils_1 = require("../../shared/utils");
const constants_1 = require("../../shared/constants");
const timeouts_1 = require("../../shared/timeouts");
const viem_1 = require("viem");
const triggerable_promise_1 = require("../../shared/triggerable-promise");
const requirements_and_support_1 = require("../../shared/requirements-and-support");
const errors_1 = require("./errors");
const deepmerge_1 = __importDefault(require("deepmerge"));
const REQUIREMENTS = {
    requirements: { symbol: 'required', decimals: 'required' },
    default: 'can ignore',
};
class QuoteService {
    constructor({ priceService, gasService, metadataService, sourceList, defaultConfig }) {
        this.priceService = priceService;
        this.gasService = gasService;
        this.metadataService = metadataService;
        this.sourceList = sourceList;
        this.defaultConfig = defaultConfig;
    }
    supportedSources() {
        const filterOutUnsupportedChains = this.metadataChainFilter();
        const entries = Object.entries(this.sourceList.supportedSources()).map(([sourceId, metadata]) => [
            sourceId,
            filterOutUnsupportedChains(metadata),
        ]);
        return Object.fromEntries(entries);
    }
    supportedChains() {
        const allChains = Object.values(this.supportedSources()).map(({ supports: { chains } }) => chains);
        return (0, _chains_1.chainsUnion)(allChains);
    }
    supportedSourcesInChain({ chainId }) {
        const sourcesInChain = Object.entries(this.supportedSources()).filter(([, source]) => source.supports.chains.includes(chainId));
        return Object.fromEntries(sourcesInChain);
    }
    supportedGasSpeeds() {
        return this.gasService.supportedSpeeds();
    }
    estimateQuotes({ request, config }) {
        const quotes = this.getQuotes({ request: estimatedToQuoteRequest(request), config });
        const entries = Object.entries(quotes).map(([sourceId, quote]) => [sourceId, quote.then(quoteResponseToEstimated)]);
        return Object.fromEntries(entries);
    }
    async estimateAllQuotes({ request, config, }) {
        const allResponses = await this.getAllQuotes({ request: estimatedToQuoteRequest(request), config });
        return allResponses.map((response) => ifNotFailed(response, quoteResponseToEstimated));
    }
    getQuotes({ request, config }) {
        const { promises, external } = this.calculateExternalPromises(request, config);
        const sources = this.calculateSources(request);
        const responses = this.sourceList.getQuotes({
            ...request,
            sources,
            external,
            quoteTimeout: config?.timeout,
            sourceConfig: this.calculateConfig(request.sourceConfig),
        });

        // Wrap each promise with response and duration
        const entries = Object.entries(responses).map(([sourceId, {response, duratoin}]) => [
            sourceId,
            { response, duration },
        ]);
        return Object.fromEntries(entries);
    }
    async getAllQuotes({ request, config, }) {
        const metadata = this.supportedSources();
        const quotes = Object.entries(this.getQuotes({ request, config })).map(([sourceId, {response, duration}]) => handleResponseFailure(sourceId, {response, duration}, metadata));
        const responses = await Promise.all(quotes);
        const successfulQuotes = responses
            .filter((response) => !('failed' in response))
            .map((quote) => ({
                ...quote,
                duration: quote.duration, // Attach duration for successful quotes
            }));
        const failedQuotes = config?.ignoredFailed === false ? responses.filter((response) => 'failed' in response) : [];
        const sortedQuotes = (0, quote_compare_1.sortQuotesBy)(successfulQuotes, config?.sort?.by ?? 'most-swapped', config?.sort?.using ?? 'sell/buy amounts');
        return [...sortedQuotes, ...failedQuotes];
    }
    async getBestQuote({ request, config, }) {
        const allQuotes = await this.getAllQuotes({
            request,
            config: {
                timeout: config?.timeout,
                sort: config?.choose,
                ignoredFailed: true,
            },
        });
        if (allQuotes.length === 0) {
            throw new errors_1.FailedToGenerateAnyQuotesError(request.chainId, request.sellToken, request.buyToken);
        }
        return allQuotes[0];
    }
    async getAllQuotesWithTxs({ request, config, }) {
        const quotes = this.getQuotes({ request, config });
        const txs = this.buildTxs({ quotes, sourceConfig: request.sourceConfig, config });
        const metadata = this.supportedSources();
        const promises = Object.keys(quotes).map((sourceId) => handleResponseFailure(sourceId, Promise.all([quotes[sourceId], txs[sourceId]]).then(([quote, tx]) => ({ ...quote, tx })), metadata));
        const responses = await Promise.all(promises);
        const successfulQuotes = responses.filter((response) => !('failed' in response));
        const failedQuotes = config?.ignoredFailed === false ? responses.filter((response) => 'failed' in response) : [];
        const sortedQuotes = (0, quote_compare_1.sortQuotesBy)(successfulQuotes, config?.sort?.by ?? 'most-swapped', config?.sort?.using ?? 'sell/buy amounts');
        return [...sortedQuotes, ...failedQuotes];
    }
    buildTxs({ quotes, config, sourceConfig, }) {
        const entries = Object.entries(quotes).map(([sourceId, response]) => (response instanceof Promise ? [sourceId, response] : [sourceId, Promise.resolve(response)]));
        const input = Object.fromEntries(entries);
        return this.sourceList.buildTxs({
            quotes: input,
            quoteTimeout: config?.timeout,
            sourceConfig: this.calculateConfig(sourceConfig),
        });
    }
    async buildAllTxs({ quotes, sourceConfig, config, }) {
        const txs = this.buildTxs({ quotes: await quotes, sourceConfig, config });
        const metadata = this.supportedSources();
        const entries = await Promise.all(Object.entries(txs).map(async ([sourceId, tx]) => [
            sourceId,
            await handleResponseFailure(sourceId, tx, metadata),
        ]));
        const result = Object.fromEntries(entries);
        if (config?.ignoredFailed !== false) {
            for (const sourceId in result) {
                if ('failed' in result[sourceId]) {
                    delete result[sourceId];
                }
            }
        }
        return result;
    }
    async listResponseToQuoteResponse({ request, response: responsePromise, promises, }) {
        const [response, tokens, prices, gasCalculator] = await Promise.all([
            responsePromise,
            promises.tokens,
            promises.prices,
            promises.gasCalculator,
        ]);
        if (!tokens)
            throw new Error(`Failed to fetch the quote's tokens`);
        if (!gasCalculator)
            throw new Error(`Failed to fetch gas data`);
        const sellToken = { ...tokens[request.sellToken], price: prices?.[request.sellToken]?.price };
        const buyToken = { ...tokens[request.buyToken], price: prices?.[request.buyToken]?.price };
        let gas;
        if (response.estimatedGas) {
            // Note: some sources provide a tx as part of the custom data, so we'll pass it just in case
            const gasCost = gasCalculator.calculateGasCost({ gasEstimation: response.estimatedGas, tx: response.customData.tx });
            const { gasCostNativeToken } = gasCost[request.gasSpeed?.speed ?? 'standard'] ?? gasCost['standard'];
            gas = {
                estimatedGas: response.estimatedGas,
                ...calculateGasDetails((0, _chains_1.getChainByKeyOrFail)(request.chainId).nativeCurrency.symbol, gasCostNativeToken, prices?.[constants_1.Addresses.NATIVE_TOKEN]?.price),
            };
        }
        return {
            chainId: request.chainId,
            sellToken: { ...sellToken, address: request.sellToken },
            buyToken: { ...buyToken, address: request.buyToken },
            sellAmount: (0, utils_1.toAmountsOfToken)({ ...sellToken, amount: response.sellAmount }),
            buyAmount: (0, utils_1.toAmountsOfToken)({ ...buyToken, amount: response.buyAmount }),
            maxSellAmount: (0, utils_1.toAmountsOfToken)({ ...sellToken, amount: response.maxSellAmount }),
            minBuyAmount: (0, utils_1.toAmountsOfToken)({ ...buyToken, amount: response.minBuyAmount }),
            gas,
            accounts: { takerAddress: request.takerAddress, recipient: response.recipient },
            source: response.source,
            type: response.type,
            customData: response.customData,
        };
    }
    calculateSources({ filters, includeNonTransferSourcesWhenRecipientIsSet, estimateBuyOrdersWithSellOnlySources, ...request }) {
        const sourcesInChain = this.supportedSourcesInChain(request);
        let sourceIds = Object.keys(sourcesInChain);
        if (filters?.includeSources) {
            sourceIds = sourceIds.filter((id) => filters.includeSources.includes(id));
        }
        else if (filters?.excludeSources) {
            sourceIds = sourceIds.filter((id) => !filters.excludeSources.includes(id));
        }
        if (request.order.type === 'buy' && !estimateBuyOrdersWithSellOnlySources) {
            sourceIds = sourceIds.filter((sourceIds) => sourcesInChain[sourceIds].supports.buyOrders);
        }
        if (request.recipient && request.recipient !== request.takerAddress && !includeNonTransferSourcesWhenRecipientIsSet) {
            sourceIds = sourceIds.filter((sourceIds) => sourcesInChain[sourceIds].supports.swapAndTransfer);
        }
        return sourceIds;
    }
    calculateExternalPromises(request, config) {
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config?.timeout, '200');
        const selectedGasSpeed = request.gasSpeed?.speed ?? 'standard';
        const tokens = this.metadataService
            .getMetadataInChain({
            chainId: request.chainId,
            tokens: [request.sellToken, request.buyToken],
            config: {
                timeout: reducedTimeout,
                fields: REQUIREMENTS,
            },
        })
            .catch(() => undefined);
        const prices = this.priceService
            .getCurrentPricesInChain({
            chainId: request.chainId,
            tokens: [request.sellToken, request.buyToken, constants_1.Addresses.NATIVE_TOKEN],
            config: { timeout: reducedTimeout },
        })
            .catch(() => undefined);
        const gasCalculator = this.gasService
            .getQuickGasCalculator({
            chainId: request.chainId,
            config: {
                timeout: reducedTimeout,
                fields: {
                    requirements: {
                        [selectedGasSpeed]: request.gasSpeed?.requirement ?? 'best effort',
                        standard: 'required',
                    },
                    default: 'can ignore',
                },
            },
        })
            .catch(() => undefined);
        return {
            promises: { tokens, prices, gasCalculator },
            external: {
                tokenData: new triggerable_promise_1.TriggerablePromise(() => tokens.then((tokens) => {
                    return tokens
                        ? { sellToken: tokens[request.sellToken], buyToken: tokens[request.buyToken] }
                        : Promise.reject(new Error(`Failed to fetch the quote's tokens`));
                })),
                gasPrice: new triggerable_promise_1.TriggerablePromise(() => gasCalculator.then((calculator) => {
                    if (!calculator)
                        return Promise.reject(new Error(`Failed to fetch gas data`));
                    const gasPrice = calculator.getGasPrice();
                    return gasPrice[selectedGasSpeed] ?? gasPrice['standard'];
                })),
            },
        };
    }
    // There are some properties that are necessary for the quote service to work, so we'll filter out chains where
    // those properties are not available
    metadataChainFilter() {
        const tokenProperties = this.metadataService.supportedProperties();
        return (metadata) => ({
            ...metadata,
            supports: {
                ...metadata.supports,
                chains: metadata.supports.chains.filter((chainId) => (0, requirements_and_support_1.couldSupportMeetRequirements)(tokenProperties[chainId], REQUIREMENTS)),
            },
        });
    }
    calculateConfig(sourceConfigs) {
        return {
            global: (0, deepmerge_1.default)(this.defaultConfig?.global ?? {}, sourceConfigs?.global ?? {}),
            custom: (0, deepmerge_1.default)(this.defaultConfig?.custom ?? {}, sourceConfigs?.custom ?? {}),
        };
    }
}
exports.QuoteService = QuoteService;
function ifNotFailed(response, mapped) {
    return ('failed' in response ? response : mapped(response));
}
function estimatedToQuoteRequest(request) {
    return {
        ...request,
        sourceConfig: {
            ...request.sourceConfig,
            global: {
                ...request.sourceConfig?.global,
                disableValidation: true,
            },
        },
        takerAddress: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', // We set a random taker address so that txs can be built at the source level
    };
}
function quoteResponseToEstimated({ accounts, ...response }) {
    return response;
}
function calculateGasDetails(gasTokenSymbol, gasCostNativeToken, nativeTokenPrice) {
    return {
        estimatedCost: BigInt(gasCostNativeToken),
        estimatedCostInUnits: (0, viem_1.formatUnits)(BigInt(gasCostNativeToken), 18),
        estimatedCostInUSD: (0, utils_1.amountToUSD)(18, gasCostNativeToken, nativeTokenPrice),
        gasTokenPrice: nativeTokenPrice,
        gasTokenSymbol,
    };
}
exports.calculateGasDetails = calculateGasDetails;
function handleResponseFailure(sourceId, { response, duration }, sources) {
    console.log(`Handling response failure for sourceId: ${sourceId}`);
    console.log("Response data:", response);
    console.log("Duration:", duration);

    // Ensure response is treated as a Promise
    const safeResponse = response instanceof Promise ? response : Promise.reject(new Error("Invalid response object"));

    return safeResponse.catch((e) => {
        const metadata = sources[sourceId];
        console.error(`Invalid response object for sourceId: ${sourceId}`);
        return {
            failed: true,
            source: {
                id: sourceId,
                name: metadata.name,
                logoURI: metadata.logoURI,
            },
            error: e instanceof Error ? e.message : JSON.stringify(e),
            duration: duration || "N/A", // Attach response time for failed requests
        };
    });
}

exports.handleResponseFailure = handleResponseFailure;
//# sourceMappingURL=quote-service.js.map