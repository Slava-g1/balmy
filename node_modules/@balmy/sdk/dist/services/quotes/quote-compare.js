"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareQuotesBy = exports.chooseQuotesBy = exports.sortQuotesBy = exports.COMPARE_USING = exports.COMPARE_BY = void 0;
const utils_1 = require("../../shared/utils");
exports.COMPARE_BY = [
    // Compare spent gas and prioritize the ones with the least spent gas
    'least-gas',
    // Compare rates in terms of input vs output and prioritize the ones with the better rate
    'most-swapped',
    // Compare input vs output but take gas into account. So if a quote has a better rate but it's far more
    // expensive in terms of gas, then it won't be prioritized. This compare method needs the usd price of the tokens
    // to be available. If it isn't, it will default to 'most-swapped'
    'most-swapped-accounting-for-gas',
];
exports.COMPARE_USING = ['sell/buy amounts', 'max sell/min buy amounts'];
function sortQuotesBy(quotes, sortBy, using) {
    const compareFtn = getCompareFtn(sortBy);
    return quotes.sort((q1, q2) => compareFtn(q1, q2, using));
}
exports.sortQuotesBy = sortQuotesBy;
function chooseQuotesBy(quotes, sortBy, using) {
    if (quotes.length === 0)
        throw new Error(`There are no quotes to choose from`);
    const compareFtn = getCompareFtn(sortBy);
    return quotes.reduce((q1, q2) => (compareFtn(q1, q2, using) <= 0 ? q1 : q2));
}
exports.chooseQuotesBy = chooseQuotesBy;
function compareQuotesBy(sortBy, using) {
    const compareFtn = getCompareFtn(sortBy);
    return (quote1, quote2) => compareFtn(quote1, quote2, using);
}
exports.compareQuotesBy = compareQuotesBy;
function getCompareFtn(compareBy) {
    let prioritizedCompareFns;
    switch (compareBy) {
        case 'most-swapped-accounting-for-gas':
            prioritizedCompareFns = [compareMostProfit, compareByMostSwapped, compareLeastGas];
            break;
        case 'most-swapped':
            prioritizedCompareFns = [compareByMostSwapped, compareLeastGas];
            break;
        case 'least-gas':
            prioritizedCompareFns = [compareLeastGas, compareMostProfit, compareByMostSwapped];
            break;
    }
    return mergeCompareFtns(prioritizedCompareFns);
}
function amountExtractor(using) {
    return using === 'sell/buy amounts'
        ? ({ sellAmount, buyAmount }) => ({ sellAmount, buyAmount })
        : ({ maxSellAmount, minBuyAmount }) => ({ sellAmount: maxSellAmount, buyAmount: minBuyAmount });
}
function mergeCompareFtns(prioritizedCompareFns) {
    return (quote1, quote2, using) => prioritizedCompareFns.reduce((accumCompareValue, compare) => accumCompareValue || compare(quote1, quote2, using), 0);
}
function compareMostProfit(quote1, quote2, using) {
    const [profit1, profit2] = [calculateProfit(quote1, using), calculateProfit(quote2, using)];
    if (!profit1 || !profit2) {
        if (!profit1 && !profit2) {
            return 0;
        }
        else if (profit1) {
            return -1;
        }
        else {
            return 1;
        }
    }
    else if (profit1 === profit2) {
        return 0;
    }
    else {
        return profit1 > profit2 ? -1 : 1;
    }
}
function compareByMostSwapped(quote1, quote2, using) {
    if (!(0, utils_1.isSameAddress)(quote1.sellToken.address, quote2.sellToken.address) || !(0, utils_1.isSameAddress)(quote1.buyToken.address, quote2.buyToken.address)) {
        // If we are compating for different pairs, then we'll check profit without gas
        const [profit1, profit2] = [calculateProfitWithoutGas(quote1, using), calculateProfitWithoutGas(quote2, using)];
        if (!profit1 || !profit2) {
            if (!profit1 && !profit2) {
                return 0;
            }
            else if (profit1) {
                return -1;
            }
            else {
                return 1;
            }
        }
        else if (profit1 === profit2) {
            return 0;
        }
        else {
            return profit1 > profit2 ? -1 : 1;
        }
    }
    // If we are comparing quotes for the same pair of tokens, then will simply compare swap ammounts
    const extract = amountExtractor(using);
    const { sellAmount: sellAmount1, buyAmount: buyAmount1 } = extract(quote1);
    const { sellAmount: sellAmount2, buyAmount: buyAmount2 } = extract(quote2);
    const quote1BuyAmountRelativeToQuote2 = (0, utils_1.ruleOfThree)({ a: sellAmount1.amount, matchA: buyAmount1.amount, b: sellAmount2.amount });
    if (BigInt(quote1BuyAmountRelativeToQuote2) > BigInt(buyAmount2.amount)) {
        return -1;
    }
    else if (BigInt(quote1BuyAmountRelativeToQuote2) < BigInt(buyAmount2.amount)) {
        return 1;
    }
    return 0;
}
function compareLeastGas(quote1, quote2) {
    if (!quote1.gas || !quote2.gas) {
        if (!quote1.gas && !quote2.gas) {
            return 0;
        }
        else if (quote1.gas) {
            return -1;
        }
        else {
            return 1;
        }
    }
    else if (BigInt(quote1.gas.estimatedGas) < BigInt(quote2.gas.estimatedGas)) {
        return -1;
    }
    else if (BigInt(quote1.gas.estimatedGas) > BigInt(quote2.gas.estimatedGas)) {
        return 1;
    }
    return 0;
}
function calculateProfit(quote, using) {
    const { sellAmount, buyAmount } = amountExtractor(using)(quote);
    const soldUSD = sellAmount.amountInUSD && Number(sellAmount.amountInUSD);
    const boughtUSD = buyAmount.amountInUSD && Number(buyAmount.amountInUSD);
    const gasCostUSD = quote.gas?.estimatedCostInUSD && Number(quote.gas.estimatedCostInUSD);
    return !soldUSD || !boughtUSD || !gasCostUSD ? undefined : boughtUSD - soldUSD - gasCostUSD;
}
function calculateProfitWithoutGas(quote, using) {
    const { sellAmount, buyAmount } = amountExtractor(using)(quote);
    const soldUSD = sellAmount.amountInUSD && Number(sellAmount.amountInUSD);
    const boughtUSD = buyAmount.amountInUSD && Number(buyAmount.amountInUSD);
    return !soldUSD || !boughtUSD ? undefined : boughtUSD - soldUSD;
}
//# sourceMappingURL=quote-compare.js.map