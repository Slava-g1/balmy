"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourcesThatSupportRequestOrFail = exports.filterRequestForSource = exports.doesResponseFulfilRequest = exports.fillResponseWithNewResult = void 0;
function fillResponseWithNewResult(result, newResult) {
    for (const chainId in newResult) {
        if (!(chainId in result))
            result[chainId] = {};
        for (const address in newResult[chainId]) {
            if (!(address in result[chainId]))
                result[chainId][address] = {};
            for (const token in newResult[chainId][address]) {
                if (!result[chainId]?.[address]?.[token]) {
                    result[chainId][address][token] = newResult[chainId][address][token];
                }
            }
        }
    }
}
exports.fillResponseWithNewResult = fillResponseWithNewResult;
function doesResponseFulfilRequest(result, request) {
    const missing = [];
    for (const { chainId, token, account } of request) {
        if (typeof result[chainId]?.[account]?.[token] === 'undefined') {
            missing.push({ chainId, account, token });
        }
    }
    return missing.length > 0 ? { ok: false, missing } : { ok: true };
}
exports.doesResponseFulfilRequest = doesResponseFulfilRequest;
function filterRequestForSource(request, source) {
    const support = source.supportedChains();
    return request.filter(({ chainId }) => support.includes(chainId));
}
exports.filterRequestForSource = filterRequestForSource;
function getSourcesThatSupportRequestOrFail(request, sources) {
    const chainsInRequest = new Set(request.map(({ chainId }) => chainId));
    const sourcesInChain = sources.filter((source) => source.supportedChains().some((chainId) => chainsInRequest.has(chainId)));
    if (sourcesInChain.length === 0)
        throw new Error('Operation not supported');
    return sourcesInChain;
}
exports.getSourcesThatSupportRequestOrFail = getSourcesThatSupportRequestOrFail;
//# sourceMappingURL=utils.js.map