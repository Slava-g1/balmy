"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCBalanceSource = void 0;
const erc20_1 = __importDefault(require("../../../shared/abis/erc20"));
const utils_1 = require("../../providers/utils");
const utils_2 = require("../../../shared/utils");
const constants_1 = require("../../../shared/constants");
const timeouts_1 = require("../../../shared/timeouts");
class RPCBalanceSource {
    constructor(providerService, logs, config) {
        this.providerService = providerService;
        this.config = config;
        this.logger = logs.getLogger({ name: 'RPCBalanceSource' });
    }
    async getBalances({ tokens, config, }) {
        const groupedByChain = (0, utils_2.groupByChain)(tokens);
        const promises = Object.entries(groupedByChain).map(async ([chainId, tokens]) => [
            Number(chainId),
            await (0, timeouts_1.timeoutPromise)(this.fetchBalancesInChain(Number(chainId), tokens), config?.timeout, {
                reduceBy: '100',
                onTimeout: (timeout) => this.logger.debug(`Fetch balances in chain ${chainId} timeouted after ${timeout}`),
            }),
        ]);
        return Object.fromEntries(await (0, utils_2.filterRejectedResults)(promises));
    }
    supportedChains() {
        return this.providerService.supportedChains();
    }
    async fetchBalancesInChain(chainId, tokens, config) {
        const accountsToFetchNativeToken = [];
        const nonNativeTokens = [];
        for (const { account, token } of tokens) {
            if ((0, utils_2.isSameAddress)(token, constants_1.Addresses.NATIVE_TOKEN)) {
                accountsToFetchNativeToken.push(account);
            }
            else {
                nonNativeTokens.push({ account, token });
            }
        }
        const erc20Promise = Object.keys(nonNativeTokens).length > 0
            ? this.fetchERC20BalancesInChain(chainId, nonNativeTokens, config)
            : Promise.resolve({});
        const nativePromise = accountsToFetchNativeToken.length > 0
            ? this.fetchNativeBalancesInChain(chainId, accountsToFetchNativeToken, config)
            : Promise.resolve({});
        const [erc20Result, nativeResult] = await Promise.all([erc20Promise, nativePromise]);
        const result = {};
        for (const { account, token } of tokens) {
            const balance = (0, utils_2.isSameAddress)(token, constants_1.Addresses.NATIVE_TOKEN) ? nativeResult[account] : erc20Result[account]?.[token];
            if (balance !== undefined) {
                if (!(account in result))
                    result[account] = {};
                result[account][token] = balance;
            }
        }
        return result;
    }
    async fetchERC20BalancesInChain(chainId, tokens, config) {
        const contracts = tokens.map(({ account, token }) => ({
            address: token,
            abi: erc20_1.default,
            functionName: 'balanceOf',
            args: [account],
        }));
        const multicallResults = contracts.length
            ? await this.providerService.getViemPublicClient({ chainId }).multicall({
                contracts,
                multicallAddress: utils_1.MULTICALL_CONTRACT.address(chainId),
                batchSize: this.config?.batching?.maxSizeInBytes ?? 0,
            })
            : [];
        const result = {};
        for (let i = 0; i < tokens.length; i++) {
            const multicallResult = multicallResults[i];
            if (multicallResult.status === 'failure')
                continue;
            const { account, token } = tokens[i];
            if (!(account in result))
                result[account] = {};
            result[account][token] = multicallResult.result;
        }
        return result;
    }
    async fetchNativeBalancesInChain(chainId, accounts, config) {
        const entries = await Promise.all(accounts.map(async (account) => [account, await this.fetchNativeBalanceInChain(chainId, account)]));
        return Object.fromEntries(entries);
    }
    fetchNativeBalanceInChain(chainId, account, config) {
        return this.providerService.getViemPublicClient({ chainId }).getBalance({ address: account, blockTag: 'latest' });
    }
}
exports.RPCBalanceSource = RPCBalanceSource;
//# sourceMappingURL=rpc-balance-source.js.map