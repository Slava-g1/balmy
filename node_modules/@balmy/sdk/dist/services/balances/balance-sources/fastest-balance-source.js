"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FastestBalanceSource = void 0;
const timeouts_1 = require("../../../shared/timeouts");
const _chains_1 = require("../../../chains");
const utils_1 = require("./utils");
// This source will take a list of sources and combine the results of each one to try to fulfil
// the request. As soon as there there is a response that is valid for the request, it will be returned
class FastestBalanceSource {
    constructor(sources, logs) {
        this.sources = sources;
        if (sources.length === 0)
            throw new Error('No sources were specified');
        this.logger = logs.getLogger({ name: 'FastestBalanceSource' });
    }
    supportedChains() {
        return (0, _chains_1.chainsUnion)(this.sources.map((source) => source.supportedChains()));
    }
    getBalances({ tokens, config, }) {
        const sourcesInChains = (0, utils_1.getSourcesThatSupportRequestOrFail)(tokens, this.sources);
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config?.timeout, '100');
        return new Promise(async (resolve, reject) => {
            const result = {};
            const allPromises = sourcesInChains.map((source) => (0, timeouts_1.timeoutPromise)(source.getBalances({
                tokens: (0, utils_1.filterRequestForSource)(tokens, source),
                config: { timeout: reducedTimeout },
            }), reducedTimeout).then((response) => {
                (0, utils_1.fillResponseWithNewResult)(result, response);
                if ((0, utils_1.doesResponseFulfilRequest)(result, tokens).ok) {
                    resolve(result);
                }
            }));
            Promise.allSettled(allPromises).then(() => {
                const isOk = (0, utils_1.doesResponseFulfilRequest)(result, tokens);
                if (!isOk.ok) {
                    // We couldn't fulfil the request, so we know we didn't resolve. We will revert then
                    const missingText = isOk.missing.map(({ chainId, account, token }) => `${chainId}-${account}-${token}`).join(',');
                    reject(new Error(`Failed to fulfil request: missing: ${missingText}`));
                }
            });
        });
    }
}
exports.FastestBalanceSource = FastestBalanceSource;
//# sourceMappingURL=fastest-balance-source.js.map