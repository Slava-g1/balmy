"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCMetadataSource = void 0;
const _chains_1 = require("../../../chains");
const constants_1 = require("../../../shared/constants");
const utils_1 = require("../../../shared/utils");
const timeouts_1 = require("../../../shared/timeouts");
const requirements_and_support_1 = require("../../../shared/requirements-and-support");
const erc20_1 = __importDefault(require("../../../shared/abis/erc20"));
const utils_2 = require("../../providers/utils");
const SUPPORT = { symbol: 'present', decimals: 'present', name: 'present' };
class RPCMetadataSource {
    constructor(providerService) {
        this.providerService = providerService;
    }
    async getMetadata({ tokens, config, }) {
        const groupedByChain = (0, utils_1.groupByChain)(tokens, ({ token }) => token);
        const promises = Object.entries(groupedByChain).map(async ([chainId, tokens]) => [
            Number(chainId),
            await (0, timeouts_1.timeoutPromise)(this.fetchMetadataInChain(Number(chainId), tokens, config?.fields), config?.timeout, { reduceBy: '100' }),
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
    }
    supportedProperties() {
        return Object.fromEntries(this.providerService.supportedChains().map((chainId) => [chainId, SUPPORT]));
    }
    async fetchMetadataInChain(chainId, tokens, requirements) {
        const chain = (0, _chains_1.getChainByKey)(chainId);
        const addressesWithoutNativeToken = tokens.filter((address) => !(0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN));
        const fieldRequirements = (0, requirements_and_support_1.calculateFieldRequirements)(SUPPORT, requirements);
        const fieldsToFetch = Object.entries(fieldRequirements)
            .filter(([, requirement]) => requirement !== 'can ignore')
            .map(([field]) => field);
        if (fieldsToFetch.length === 0)
            return {};
        const contracts = [];
        for (const field of fieldsToFetch) {
            contracts.push(...addressesWithoutNativeToken.map((address) => ({ address: address, functionName: field, abi: erc20_1.default })));
        }
        const multicallResults = contracts.length
            ? await this.providerService
                .getViemPublicClient({ chainId })
                .multicall({ contracts, allowFailure: false, multicallAddress: utils_2.MULTICALL_CONTRACT.address(chainId), batchSize: 0 })
            : [];
        const result = {};
        for (let i = 0; i < addressesWithoutNativeToken.length; i++) {
            const address = addressesWithoutNativeToken[i];
            const tokenMetadata = Object.fromEntries(fieldsToFetch.map((field, j) => [field, multicallResults[addressesWithoutNativeToken.length * j + i]]));
            result[address] = tokenMetadata;
        }
        if (addressesWithoutNativeToken.length !== tokens.length) {
            const nativeResult = {};
            if (fieldsToFetch.includes('symbol')) {
                nativeResult.symbol = chain?.nativeCurrency?.symbol ?? '???';
            }
            if (fieldsToFetch.includes('decimals')) {
                nativeResult.decimals = 18;
            }
            if (fieldsToFetch.includes('name')) {
                nativeResult.name = chain?.nativeCurrency?.name ?? 'Unknown';
            }
            result[constants_1.Addresses.NATIVE_TOKEN] = nativeResult;
        }
        return result;
    }
}
exports.RPCMetadataSource = RPCMetadataSource;
//# sourceMappingURL=rpc-metadata-source.js.map