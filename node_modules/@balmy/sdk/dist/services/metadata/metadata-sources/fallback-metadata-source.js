"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FallbackMetadataSource = void 0;
const timeouts_1 = require("../../../shared/timeouts");
const requirements_and_support_1 = require("../../../shared/requirements-and-support");
const utils_1 = require("../../../shared/utils");
// This fallback source will use different sources and combine the results of each of them
class FallbackMetadataSource {
    constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
            throw new Error('Need at least one source to setup a fallback token source');
    }
    // @ts-ignore Will get 'Return type annotation circularly references itself' if not ignored
    getMetadata({ tokens, config, }) {
        return new Promise((resolve, reject) => {
            const chainsInRequest = [...new Set(tokens.map(({ chainId }) => chainId))];
            const sources = this.sources.filter((source) => doesSourceSupportAtLeastOneChain(source, chainsInRequest));
            if (sources.length === 0) {
                reject(new Error(`Couldn't find sources that supported the given chains`));
            }
            const result = {};
            const requirements = (0, requirements_and_support_1.calculateFieldRequirementsPerChain)(this.supportedProperties(), config?.fields);
            const requestTracker = buildRequestTracker(sources, tokens, requirements);
            const handleFulfil = (source) => {
                updateCounterWhenSourceFulfilled(source, requestTracker);
                const status = checkStatus(requestTracker);
                if (status === 'finished') {
                    resolve(result);
                }
                else if (status === 'error') {
                    reject(new Error('Could not find metadata for the given addresses'));
                }
            };
            sources.forEach(async (source) => {
                const tokensForSource = getAddressesForSource(source, tokens);
                const reducedTimeout = (0, timeouts_1.reduceTimeout)(config?.timeout, '100');
                try {
                    // Some requirements might not be compatible with all sources, so we need to filter them before
                    // passing them to the source. This is so that the underlying source doesn't fail
                    const filteredRequirements = (0, requirements_and_support_1.makeRequirementsCompatible)(source.supportedProperties(), [...new Set(tokensForSource.map(({ chainId }) => chainId))], config?.fields);
                    const sourceResult = await (0, timeouts_1.timeoutPromise)(source.getMetadata({
                        tokens: tokensForSource,
                        config: { timeout: reducedTimeout, fields: filteredRequirements },
                    }), reducedTimeout);
                    for (const [chainIdString, metadataRecord] of Object.entries(sourceResult)) {
                        const chainId = Number(chainIdString);
                        const metadatas = Object.entries(metadataRecord);
                        if (!(chainId in result) && metadatas.length > 0)
                            result[chainId] = {};
                        for (const [address, metadata] of metadatas) {
                            // Add to result
                            result[chainId][address] = { ...result[chainId][address], ...metadata };
                            // Remove token address from counter
                            for (const tokenProperty in metadata) {
                                const property = tokenProperty;
                                requestTracker?.[chainId]?.[property]?.tokens?.delete(address);
                            }
                        }
                    }
                }
                catch {
                    // Handle, but do nothing
                }
                finally {
                    handleFulfil(source);
                }
            });
        });
    }
    // @ts-ignore Will get 'Return type annotation circularly references itself' if not ignored
    supportedProperties() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedProperties());
    }
}
exports.FallbackMetadataSource = FallbackMetadataSource;
function buildRequestTracker(sources, tokens, fieldRequirements) {
    const groupedByChain = (0, utils_1.groupByChain)(tokens, ({ token }) => token);
    const requestTracker = {};
    for (const [chainIdString, addressesInChain] of Object.entries(groupedByChain)) {
        const chainId = Number(chainIdString);
        requestTracker[chainId] = Object.fromEntries(Object.entries(fieldRequirements[chainId]).map(([property, requirement]) => [
            property,
            { sources: 0, tokens: new Set(addressesInChain), requirement },
        ]));
        for (const source of sources) {
            const supportedProperties = source.supportedProperties();
            if (chainId in supportedProperties) {
                for (const property in supportedProperties[chainId]) {
                    requestTracker[chainId][property].sources += 1;
                }
            }
        }
    }
    return requestTracker;
}
function updateCounterWhenSourceFulfilled(source, requestTracker) {
    const supportedProperties = source.supportedProperties();
    for (const [chainId, properties] of Object.entries(supportedProperties)) {
        if (chainId in requestTracker) {
            for (const property in properties) {
                requestTracker[Number(chainId)][property].sources -= 1;
            }
        }
    }
}
function checkStatus(requestTracker) {
    let result = 'finished';
    for (const chainId in requestTracker) {
        for (const { sources, tokens, requirement } of Object.values(requestTracker[chainId])) {
            if (sources === 0 && tokens.size > 0 && requirement === 'required') {
                return 'error';
            }
            else if (sources > 0 && tokens.size > 0 && requirement !== 'can ignore') {
                result = 'continue';
            }
        }
    }
    return result;
}
function getAddressesForSource(source, tokens) {
    const chainsForSource = new Set(Object.keys(source.supportedProperties()).map(Number));
    return tokens.filter(({ chainId }) => chainsForSource.has(chainId));
}
function doesSourceSupportAtLeastOneChain(source, chainIds) {
    return Object.keys(source.supportedProperties())
        .map(Number)
        .some((chainId) => chainIds.includes(chainId));
}
//# sourceMappingURL=fallback-metadata-source.js.map