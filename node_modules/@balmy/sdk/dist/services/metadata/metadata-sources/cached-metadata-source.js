"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedMetadataSource = void 0;
const concurrent_lru_cache_1 = require("../../../shared/concurrent-lru-cache");
const requirements_and_support_1 = require("../../../shared/requirements-and-support");
class CachedMetadataSource {
    constructor(source, config) {
        this.source = source;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCacheWithContext({
            calculate: (context, tokensInChain) => this.fetchMetadata(tokensInChain, context),
            config,
        });
    }
    async getMetadata({ tokens, config, }) {
        const chainIds = [...new Set(tokens.map(({ chainId }) => chainId))];
        const support = (0, requirements_and_support_1.combineSupportInChains)(chainIds, this.supportedProperties());
        const fieldRequirements = (0, requirements_and_support_1.calculateFieldRequirements)(support, config?.fields);
        const requiredFields = Object.entries(fieldRequirements)
            .filter(([, requirement]) => requirement === 'required')
            .map(([field]) => field);
        const tokensInChain = addressesToTokensInChain(tokens, requiredFields);
        const result = await this.cache.getOrCalculate({
            context: config,
            keys: tokensInChain,
            timeout: config?.timeout,
        });
        return tokenInChainRecordToChainAndAddress(result);
    }
    supportedProperties() {
        return this.source.supportedProperties();
    }
    async fetchMetadata(tokensInChain, context) {
        const { tokens, requiredFields } = tokensInChainToAddresses(tokensInChain);
        const requirements = Object.fromEntries(requiredFields.map((field) => [field, 'required']));
        // We set the default to best effort here, even if it wasn't set on the original request. The idea is that we try our best to fetch all properties,
        // so that if we have a future request with the same required fields and best effort is set, then we can use the cached values
        const metadata = (await this.source.getMetadata({
            tokens,
            config: { timeout: context?.timeout, fields: { requirements, default: 'best effort' } },
        }));
        return chainAndAddressRecordToTokenInChain(metadata, requiredFields);
    }
}
exports.CachedMetadataSource = CachedMetadataSource;
function addressesToTokensInChain(tokens, requiredFields) {
    return tokens.map(({ chainId, token }) => toTokenInChain(chainId, token, requiredFields));
}
function tokensInChainToAddresses(tokensInChain) {
    const result = [];
    let requiredFieldsResult = [];
    for (const tokenInChain of tokensInChain) {
        const { chainId, address, requiredFields } = fromTokenInChain(tokenInChain);
        requiredFieldsResult = requiredFields; // All tokens should have the same required fields
        result.push({ chainId, token: address });
    }
    return { tokens: result, requiredFields: requiredFieldsResult };
}
function tokenInChainRecordToChainAndAddress(record) {
    const result = {};
    for (const [tokenInChain, token] of Object.entries(record)) {
        const { chainId, address } = fromTokenInChain(tokenInChain);
        if (!(chainId in result)) {
            result[chainId] = {};
        }
        result[chainId][address] = token;
    }
    return result;
}
function chainAndAddressRecordToTokenInChain(record, requiredFields) {
    const entries = Object.entries(record).flatMap(([chainId, record]) => Object.entries(record).map(([address, token]) => [
        toTokenInChain(Number(chainId), address, requiredFields),
        token,
    ]));
    return Object.fromEntries(entries);
}
function toTokenInChain(chainId, address, requiredFields) {
    return `${chainId}-${address}-${requiredFields.join(',')}`;
}
function fromTokenInChain(tokenInChain) {
    const [chainId, address, requiredFields] = tokenInChain.split('-');
    return {
        chainId: Number(chainId),
        address,
        requiredFields: requiredFields.length > 0 ? requiredFields.split(',') : [],
    };
}
//# sourceMappingURL=cached-metadata-source.js.map