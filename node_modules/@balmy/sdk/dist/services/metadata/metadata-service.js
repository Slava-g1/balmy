"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataService = void 0;
const requirements_and_support_1 = require("../../shared/requirements-and-support");
const timeouts_1 = require("../../shared/timeouts");
class MetadataService {
    constructor(metadataSource) {
        this.metadataSource = metadataSource;
    }
    supportedChains() {
        return Object.keys(this.supportedProperties()).map(Number);
    }
    supportedProperties() {
        return this.metadataSource.supportedProperties();
    }
    async getMetadataInChain({ chainId, tokens, config, }) {
        const result = await this.getMetadata({ tokens: tokens.map((token) => ({ chainId, token })), config });
        return result[chainId] ?? {};
    }
    async getMetadata({ tokens, config, }) {
        if (tokens.length === 0)
            return {};
        const chains = [...new Set(tokens.map(({ chainId }) => chainId))];
        (0, requirements_and_support_1.validateRequirements)(this.supportedProperties(), chains, config?.fields);
        const response = await (0, timeouts_1.timeoutPromise)(this.metadataSource.getMetadata({ tokens, config }), config?.timeout);
        validateResponse(tokens, response, config?.fields);
        return response;
    }
}
exports.MetadataService = MetadataService;
function validateResponse(request, response, requirements) {
    for (const { chainId, token } of request) {
        if (!(0, requirements_and_support_1.doesResponseMeetRequirements)(response[chainId]?.[token], requirements)) {
            throw new Error('Failed to fetch metadata that meets the given requirements');
        }
    }
}
//# sourceMappingURL=metadata-service.js.map