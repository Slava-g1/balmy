"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPriceService = void 0;
const defi_llama_price_source_1 = require("../../services/prices/price-sources/defi-llama-price-source");
const price_service_1 = require("../../services/prices/price-service");
const cached_price_source_1 = require("../../services/prices/price-sources/cached-price-source");
const odos_price_source_1 = require("../../services/prices/price-sources/odos-price-source");
const coingecko_price_source_1 = require("../../services/prices/price-sources/coingecko-price-source");
const prioritized_price_source_1 = require("../../services/prices/price-sources/prioritized-price-source");
const fastest_price_source_1 = require("../../services/prices/price-sources/fastest-price-source");
const aggregator_price_source_1 = require("../../services/prices/price-sources/aggregator-price-source");
const balmy_price_source_1 = require("../../services/prices/price-sources/balmy-price-source");
function buildPriceService(params, fetchService) {
    const source = buildSource(params?.source, { fetchService });
    return new price_service_1.PriceService(source);
}
exports.buildPriceService = buildPriceService;
function buildSource(source, { fetchService }) {
    const coingecko = new coingecko_price_source_1.CoingeckoPriceSource(fetchService);
    const defiLlama = new defi_llama_price_source_1.DefiLlamaPriceSource(fetchService);
    switch (source?.type) {
        case undefined:
            // Defi Llama is basically Coingecko with some token mappings. Defi Llama has a 5 min cache, so the priority will be Coingecko => DefiLlama
            return new prioritized_price_source_1.PrioritizedPriceSource([coingecko, defiLlama]);
        case 'defi-llama':
            return defiLlama;
        case 'odos':
            return new odos_price_source_1.OdosPriceSource(fetchService);
        case 'balmy':
            return new balmy_price_source_1.BalmyPriceSource(fetchService, source.apiKey);
        case 'coingecko':
            return coingecko;
        case 'cached':
            const underlying = buildSource(source.underlyingSource, { fetchService });
            return new cached_price_source_1.CachedPriceSource(underlying, source.config);
        case 'prioritized':
            return new prioritized_price_source_1.PrioritizedPriceSource(source.sources.map((source) => buildSource(source, { fetchService })));
        case 'fastest':
            return new fastest_price_source_1.FastestPriceSource(source.sources.map((source) => buildSource(source, { fetchService })));
        case 'aggregate':
            return new aggregator_price_source_1.AggregatorPriceSource(source.sources.map((source) => buildSource(source, { fetchService })), source.by);
        case 'custom':
            return source.instance;
    }
}
//# sourceMappingURL=price-builder.js.map