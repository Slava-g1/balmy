"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toChainId = exports.DefiLlamaClient = void 0;
const constants_1 = require("./constants");
const _chains_1 = require("../chains");
const utils_1 = require("./utils");
const CHAIN_ID_TO_KEY = {
    [_chains_1.Chains.ETHEREUM.chainId]: 'ethereum',
    [_chains_1.Chains.BNB_CHAIN.chainId]: 'bsc',
    [_chains_1.Chains.POLYGON.chainId]: 'polygon',
    [_chains_1.Chains.AVALANCHE.chainId]: 'avax',
    [_chains_1.Chains.FANTOM.chainId]: 'fantom',
    [_chains_1.Chains.GNOSIS.chainId]: 'xdai',
    [_chains_1.Chains.HECO.chainId]: 'heco',
    [_chains_1.Chains.ARBITRUM.chainId]: 'arbitrum',
    [_chains_1.Chains.OPTIMISM.chainId]: 'optimism',
    [_chains_1.Chains.CELO.chainId]: 'celo',
    [_chains_1.Chains.CRONOS.chainId]: 'cronos',
    [_chains_1.Chains.BOBA.chainId]: 'boba',
    [_chains_1.Chains.MOONRIVER.chainId]: 'moonriver',
    [_chains_1.Chains.OKC.chainId]: 'okexchain',
    [_chains_1.Chains.ONTOLOGY.chainId]: 'ontology',
    [_chains_1.Chains.KAIA.chainId]: 'klaytn',
    [_chains_1.Chains.AURORA.chainId]: 'aurora',
    [_chains_1.Chains.HARMONY_SHARD_0.chainId]: 'harmony',
    [_chains_1.Chains.MOONBEAM.chainId]: 'moonbeam',
    [_chains_1.Chains.VELAS.chainId]: 'velas',
    [_chains_1.Chains.ROOTSTOCK.chainId]: 'rsk',
    [_chains_1.Chains.EVMOS.chainId]: 'evmos',
    [_chains_1.Chains.CANTO.chainId]: 'canto',
    [_chains_1.Chains.POLYGON_ZKEVM.chainId]: 'polygon_zkevm',
    [_chains_1.Chains.KAVA.chainId]: 'kava',
    [_chains_1.Chains.BASE.chainId]: 'base',
    [_chains_1.Chains.LINEA.chainId]: 'linea',
    [_chains_1.Chains.MODE.chainId]: 'mode',
    [_chains_1.Chains.BLAST.chainId]: 'blast',
    [_chains_1.Chains.SCROLL.chainId]: 'scroll',
    [_chains_1.Chains.MANTLE.chainId]: 'mantle',
    [_chains_1.Chains.METIS_ANDROMEDA.chainId]: 'metis',
};
const KEY_TO_CHAIN_ID = Object.fromEntries(Object.entries(CHAIN_ID_TO_KEY).map(([chainId, key]) => [key, parseInt(chainId)]));
class DefiLlamaClient {
    constructor(fetch) {
        this.fetch = fetch;
    }
    supportedChains() {
        return Object.keys(CHAIN_ID_TO_KEY).map(Number);
    }
    getCurrentTokenData({ tokens, config, }) {
        return this.fetchAndMapTokens({
            baseUrl: 'https://coins.llama.fi/prices/current/',
            tokens,
            config,
        });
    }
    getHistoricalTokenData({ tokens, timestamp, searchWidth, config, }) {
        const extraParams = searchWidth && { searchWidth };
        return this.fetchAndMapTokens({
            baseUrl: `https://coins.llama.fi/prices/historical/${timestamp}/`,
            tokens,
            extraParams,
            config,
        });
    }
    getChart({ tokens, span, period, bound, searchWidth, config, }) {
        const extraParams = {
            span: span.toString(),
            period: period.toString(),
            ...('from' in bound && { start: bound.from.toString() }),
            ...('upTo' in bound && { end: bound.upTo === 'now' ? Math.floor(Date.now() / 1000).toString() : bound.upTo.toString() }),
            ...(searchWidth && { searchWidth }),
        };
        return this.fetchAndMapPrices({
            baseUrl: `https://coins.llama.fi/chart/`,
            tokens,
            extraParams,
            config,
        });
    }
    async getBulkHistoricalTokenData({ tokens, searchWidth, config, }) {
        searchWidth = searchWidth ?? '6h';
        const aggregatedByTokenId = aggregateTimestampsByTokenId(tokens);
        const batches = splitCoinsIntoBatches(searchWidth, aggregatedByTokenId);
        const coins = {};
        const promises = batches.map(async (batch) => {
            const response = await this.fetch.fetch(batch, { timeout: config?.timeout });
            const body = await response.json();
            for (const [tokenId, { prices }] of Object.entries(body.coins)) {
                if (!(tokenId in coins))
                    coins[tokenId] = [];
                coins[tokenId].push(...prices.map(({ timestamp, price }) => ({ price, closestTimestamp: timestamp })));
            }
        });
        await Promise.allSettled(promises);
        const result = {};
        for (const { chainId, token, timestamp } of tokens) {
            if (!(chainId in result))
                result[chainId] = {};
            if (!(token in result[chainId]))
                result[chainId][token] = {};
            const tokenId = toTokenId(Number(chainId), token);
            const allResults = coins[tokenId] ?? [];
            const bestResult = findClosestToTimestamp(allResults, timestamp);
            if (bestResult && Math.abs(bestResult.closestTimestamp - timestamp) <= (0, utils_1.timeToSeconds)(searchWidth)) {
                result[chainId][token][timestamp] = bestResult;
            }
        }
        return result;
    }
    async getClosestBlock(chainId, timestamp) {
        const chainKey = CHAIN_ID_TO_KEY[chainId];
        if (!chainKey)
            throw new Error(`Chain with id ${chainId} not supported`);
        const result = await this.fetch.fetch(`https://coins.llama.fi/block/${chainKey}/${timestamp}`);
        const { height, timestamp: blockTimestamp } = await result.json();
        return { block: BigInt(height), timestamp: blockTimestamp };
    }
    async fetchAndMapPrices({ baseUrl, tokens, extraParams, config, }) {
        const tokenIds = tokens.map(({ chainId, token }) => toTokenId(chainId, token));
        const tokensPrices = (await this.fetchTokens(baseUrl, tokenIds, config, extraParams));
        const result = Object.fromEntries(tokens.map(({ chainId }) => [chainId, {}]));
        for (const { chainId, token } of tokens) {
            const tokenId = toTokenId(chainId, token);
            const tokenPrices = tokensPrices[tokenId];
            if (tokenPrices) {
                result[chainId][token] = tokenPrices.prices.map((price) => ({ price: price.price, closestTimestamp: price.timestamp }));
            }
        }
        return result;
    }
    async fetchAndMapTokens({ baseUrl, tokens, extraParams, config, }) {
        const tokenIds = tokens.map(({ chainId, token }) => toTokenId(chainId, token));
        const coins = await this.fetchTokens(baseUrl, tokenIds, config, extraParams);
        const result = Object.fromEntries(tokens.map(({ chainId }) => [chainId, {}]));
        for (const { chainId, token } of tokens) {
            const tokenId = toTokenId(chainId, token);
            const coin = coins[tokenId];
            if (coin) {
                result[chainId][token] = { decimals: 18, ...coin };
                if ((0, utils_1.isSameAddress)(token, constants_1.Addresses.NATIVE_TOKEN)) {
                    // We'll try to overwrite the symbol for the native token, for consistency
                    const chain = (0, _chains_1.getChainByKey)(chainId);
                    if (chain) {
                        result[chainId][token].symbol = chain.nativeCurrency.symbol;
                    }
                }
            }
        }
        return result;
    }
    async fetchTokens(baseUrl, tokens, config, extraParams = {}) {
        const chunks = (0, utils_1.splitInChunks)(tokens, 30);
        const extraParamsString = '?' +
            Object.entries(extraParams)
                .map(([key, value]) => `${key}=${value}`)
                .join('&');
        const requests = chunks.map(async (chunk) => {
            const url = baseUrl + chunk.join(',') + extraParamsString;
            try {
                const response = await this.fetch.fetch(url, { timeout: config?.timeout });
                const { coins } = await response.json();
                return coins;
            }
            catch {
                throw new Error('Request to Defi Llama API failed');
            }
        });
        const responses = await Promise.all(requests);
        return responses.reduce((accum, curr) => ({ ...accum, ...curr }), {});
    }
}
exports.DefiLlamaClient = DefiLlamaClient;
const DEFI_LLAMA_NATIVE_TOKEN = '0x0000000000000000000000000000000000000000';
const MAPPINGS = {
    'polygon:0x2791bca1f2de4661ed88a30c99a7a9449aa84174': 'polygon:0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', // Bridged USDC (USDC.e): Native USDC
    'arbitrum:0xff970a61a04b1ca14834a43f5de4533ebddb5cc8': 'arbitrum:0xaf88d065e77c8cc2239327c5edb3a432268e5831', // Bridged USDC (USDC.e): Native USDC
    'optimism:0x7f5c764cbc14f9669b88837ca1490cca17c31607': 'optimism:0x0b2c639c533813f4aa9d7837caf62653d097ff85', // Bridged USDC (USDC.e): Native USDC
};
function splitCoinsIntoBatches(searchWidth, aggregatedByTokenId) {
    const searchWidthParam = searchWidth ? `&searchWidth=${searchWidth}` : '';
    const toURL = (coins) => `https://coins.llama.fi/batchHistorical?&coins=${encodeURIComponent(JSON.stringify(coins))}${searchWidthParam}`;
    const batches = [];
    let inBatch = {};
    for (const { tokenId, timestamps } of aggregatedByTokenId) {
        const ifAddedToBatch = { ...inBatch, [tokenId]: timestamps };
        const url = toURL(ifAddedToBatch);
        if (url.length > 2048) {
            if (Object.keys(inBatch).length > 0) {
                // If was something on the batch already, then close the batch
                batches.push(toURL(inBatch));
                inBatch = {};
            }
            else {
                // If there was nothing already on the batch, then we have a token too big for a batch, we'll need to split it
                const chunks = (0, utils_1.splitInChunks)(timestamps, 140);
                batches.push(...chunks.map((chunk) => toURL({ [tokenId]: chunk })));
            }
        }
        else {
            inBatch = ifAddedToBatch;
        }
    }
    if (Object.keys(inBatch).length > 0) {
        // If there was anything left, add it
        batches.push(toURL(inBatch));
    }
    return batches;
}
function aggregateTimestampsByTokenId(addresses) {
    const aggregatedByTokenId = {};
    for (const { chainId, token, timestamp } of addresses) {
        const tokenId = toTokenId(chainId, token);
        if (!(tokenId in aggregatedByTokenId))
            aggregatedByTokenId[tokenId] = [];
        aggregatedByTokenId[tokenId].push(timestamp);
    }
    return Object.entries(aggregatedByTokenId)
        .map(([tokenId, timestamps]) => ({ tokenId, timestamps }))
        .sort((a, b) => a.timestamps.length - b.timestamps.length);
}
function findClosestToTimestamp(allResults, timestamp) {
    if (allResults.length == 0)
        return undefined;
    let min = allResults[0];
    for (let i = 1; i < allResults.length; i++) {
        if (Math.abs(allResults[i].closestTimestamp - timestamp) < Math.abs(min.closestTimestamp - timestamp)) {
            min = allResults[i];
        }
    }
    return min;
}
function toTokenId(chainId, address) {
    const key = CHAIN_ID_TO_KEY[chainId];
    const toMap = ((0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? `${key}:${DEFI_LLAMA_NATIVE_TOKEN}` : `${key}:${address.toLowerCase()}`);
    return MAPPINGS[toMap] ?? toMap;
}
function toChainId(key) {
    return KEY_TO_CHAIN_ID[key.toLowerCase()];
}
exports.toChainId = toChainId;
//# sourceMappingURL=defi-llama.js.map