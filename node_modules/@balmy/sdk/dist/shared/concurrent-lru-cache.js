"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrentLRUCacheWithContext = exports.ConcurrentLRUCache = void 0;
const ms_1 = __importDefault(require("ms"));
const lru_cache_1 = require("lru-cache");
const timeouts_1 = require("./timeouts");
class ConcurrentLRUCache {
    constructor({ calculate, config, }) {
        this.cache = new ConcurrentLRUCacheWithContext({
            calculate: (_, keys) => calculate(keys),
            config,
        });
    }
    async getOrCalculateSingle({ key, expirationConfig, timeout, }) {
        return this.cache.getOrCalculateSingle({ context: undefined, key, expirationConfig, timeout });
    }
    async getOrCalculate({ keys, expirationConfig, timeout, }) {
        return this.cache.getOrCalculate({ context: undefined, keys, expirationConfig, timeout });
    }
    holdsValidValue(key, expirationConfig) {
        return this.cache.holdsValidValue(key, expirationConfig);
    }
    holdsValidValues(keys, expirationConfig) {
        return this.cache.holdsValidValues(keys, expirationConfig);
    }
    invalidate(keys) {
        return this.cache.invalidate(keys);
    }
}
exports.ConcurrentLRUCache = ConcurrentLRUCache;
class ConcurrentLRUCacheWithContext {
    constructor({ calculate, config }) {
        this.beingCalculated = new Map();
        const isInvalid = config.expiration.useCachedValue !== 'always' &&
            config.expiration.useCachedValueIfCalculationFailed !== 'always' &&
            (0, ms_1.default)(config.expiration.useCachedValue.ifUnder) > (0, ms_1.default)(config.expiration.useCachedValueIfCalculationFailed.ifUnder);
        if (isInvalid)
            throw new Error(`'useCachedValue' must be lower or equal than 'useCachedValueIfCalculationFailed'`);
        this.calculate = calculate;
        this.storableKeyMapper = (key) => key.toString().toLowerCase();
        this.expirationConfig = config.expiration;
        this.cache = new lru_cache_1.LRUCache({ max: config.maxSize });
    }
    async getOrCalculateSingle({ key, context, expirationConfig, timeout, }) {
        const result = await this.getOrCalculate({ keys: [key], context, expirationConfig, timeout });
        return result[key];
    }
    async getOrCalculate({ keys, context, expirationConfig, timeout, }) {
        const options = { ...this.expirationConfig, ...expirationConfig };
        const storableKeys = Object.fromEntries(keys.map((key) => [key, this.storableKeyMapper(key)]));
        const now = Date.now();
        const useCachedValue = ({ lastUpdated }) => options.useCachedValue === 'always' || lastUpdated >= now - (0, ms_1.default)(options.useCachedValue.ifUnder);
        const notInCache = [];
        const result = {};
        // Check if we can use cached version or we need to calculate values
        for (const key of keys) {
            const valueInCache = this.cache.get(storableKeys[key]);
            if (valueInCache && useCachedValue(valueInCache)) {
                result[key] = valueInCache.value;
            }
            else {
                notInCache.push(key);
            }
        }
        // Nothing else to calculate
        if (notInCache.length === 0)
            return result;
        // Try to calculate missing values
        const toCalculate = notInCache.filter((key) => !this.beingCalculated.has(storableKeys[key]));
        if (toCalculate.length > 0) {
            const calculated = this.calculate(context, toCalculate);
            for (const key of toCalculate) {
                const storableKey = storableKeys[key];
                const promise = calculated
                    .then((result) => {
                    const value = result[key];
                    if (value !== undefined) {
                        this.cache.set(storableKey, { lastUpdated: Date.now(), value });
                        return value;
                    }
                    return undefined;
                })
                    .catch(() => undefined)
                    .finally(() => this.beingCalculated.delete(storableKey));
                this.beingCalculated.set(storableKey, promise);
            }
        }
        // Wait for all calculations
        const calculationPromises = notInCache.map(async (key) => [
            key,
            // Note: we add the timeout here so that even though this particular request might timeout, the result is still being made in the background
            //       Once it's done, we'll fill the cache for the next time
            await (0, timeouts_1.timeoutPromise)(this.beingCalculated.get(storableKeys[key]) ?? Promise.resolve(undefined), timeout).catch(() => undefined),
        ]);
        const calculated = Object.fromEntries(await Promise.all(calculationPromises));
        const nowAgain = Date.now();
        const useCachedValueIfCalculationFailed = ({ lastUpdated }) => options.useCachedValueIfCalculationFailed === 'always' || lastUpdated >= nowAgain - (0, ms_1.default)(options.useCachedValueIfCalculationFailed.ifUnder);
        // Check all values again
        for (const key of notInCache) {
            // Check if we could calculate it
            const calculatedValue = calculated[key];
            if (calculatedValue !== undefined) {
                result[key] = calculatedValue;
            }
            else {
                // If we couldn't calculate it, check if we had an old value stored in the cache we can still use
                const storableKey = storableKeys[key];
                const valueInCache = this.cache.get(storableKey);
                if (valueInCache) {
                    if (useCachedValueIfCalculationFailed(valueInCache)) {
                        // If can use it, then add it to result
                        result[key] = valueInCache.value;
                    }
                    else {
                        // If not, then delete the value
                        this.cache.delete(storableKey);
                    }
                }
            }
        }
        return result;
    }
    holdsValidValue(key, expirationConfig) {
        const { [key]: holdsValidValue } = this.holdsValidValues([key], expirationConfig);
        return holdsValidValue;
    }
    holdsValidValues(keys, expirationConfig) {
        const options = { ...this.expirationConfig, ...expirationConfig };
        const now = Date.now();
        const isValidEntry = ({ lastUpdated }) => options.useCachedValue === 'always' || lastUpdated >= now - (0, ms_1.default)(options.useCachedValue.ifUnder);
        const entries = keys.map((key) => {
            const entry = this.cache.get(this.storableKeyMapper(key));
            const holdsValidValue = entry ? isValidEntry(entry) : false;
            return [key, holdsValidValue];
        });
        return Object.fromEntries(entries);
    }
    invalidate(keys) {
        keys.forEach((key) => this.cache.delete(this.storableKeyMapper(key)));
    }
    populate(values) {
        const now = Date.now();
        for (const key in values) {
            const storableKey = this.storableKeyMapper(key);
            this.cache.set(storableKey, { lastUpdated: now, value: values[key] });
        }
    }
}
exports.ConcurrentLRUCacheWithContext = ConcurrentLRUCacheWithContext;
//# sourceMappingURL=concurrent-lru-cache.js.map