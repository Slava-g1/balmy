"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupByChain = exports.isBigIntish = exports.toAmountsOfToken = exports.splitInChunks = exports.toTrimmedHex = exports.fromTokenInChain = exports.toTokenInChain = exports.ruleOfThree = exports.filterRejectedResults = exports.amountToUSD = exports.toUnits = exports.timeToSeconds = exports.calculateDeadline = exports.mulDivByNumber = exports.addPercentage = exports.subtractPercentage = exports.toLower = exports.isSameAddress = void 0;
const ms_1 = __importDefault(require("ms"));
const viem_1 = require("viem");
function isSameAddress(address1, address2) {
    return !!address1 && !!address2 && address1.toLowerCase() === address2.toLowerCase();
}
exports.isSameAddress = isSameAddress;
function toLower(text) {
    return text.toLowerCase();
}
exports.toLower = toLower;
function subtractPercentage(amount, slippagePercentage, rounding) {
    const percentage = mulDivByNumber(amount, slippagePercentage, 100, rounding);
    return BigInt(amount) - percentage;
}
exports.subtractPercentage = subtractPercentage;
function addPercentage(amount, slippagePercentage, rounding) {
    const percentage = mulDivByNumber(amount, slippagePercentage, 100, rounding);
    return BigInt(amount) + percentage;
}
exports.addPercentage = addPercentage;
const PRECISION = 10000000;
function mulDivByNumber(amount, mul, div, rounding) {
    const round = (num) => BigInt(Math.round(num * PRECISION));
    const numerator = BigInt(amount) * round(mul);
    const denominator = round(div);
    const result = numerator / denominator;
    return numerator % denominator !== 0n && rounding === 'up' ? result + 1n : result;
}
exports.mulDivByNumber = mulDivByNumber;
function calculateDeadline(txValidFor) {
    return txValidFor ? Math.floor((Date.now() + (0, ms_1.default)(txValidFor)) / 1000) : undefined;
}
exports.calculateDeadline = calculateDeadline;
function timeToSeconds(time) {
    return Math.floor((0, ms_1.default)(time) / 1000);
}
exports.timeToSeconds = timeToSeconds;
function toUnits(amount, decimals, precision = 5) {
    const units = (0, viem_1.formatUnits)(BigInt(amount), decimals);
    const regex = new RegExp('^-?\\d+(?:.\\d{0,' + (precision || -1) + '})?');
    return units.match(regex)[0];
}
exports.toUnits = toUnits;
const USD_PRECISION = 8;
function amountToUSD(decimals, amount, usdPrice, precision = 2) {
    if (!!usdPrice) {
        const priceBN = (0, viem_1.parseUnits)(`${usdPrice.toFixed(USD_PRECISION)}`, USD_PRECISION);
        const magnitude = (0, viem_1.parseUnits)('1', decimals);
        const amountUSDBN = (priceBN * BigInt(amount)) / magnitude;
        return toUnits(amountUSDBN.toString(), USD_PRECISION, precision);
    }
    return undefined;
}
exports.amountToUSD = amountToUSD;
async function filterRejectedResults(promises) {
    const results = await Promise.allSettled(promises);
    return results.filter((result) => result.status === 'fulfilled').map(({ value }) => value);
}
exports.filterRejectedResults = filterRejectedResults;
function ruleOfThree({ a, matchA, b }) {
    const matchABN = BigInt(matchA);
    const bBN = BigInt(b);
    if (bBN === 0n || matchABN === 0n)
        return 0n;
    return (bBN * matchABN) / BigInt(a);
}
exports.ruleOfThree = ruleOfThree;
function toTokenInChain(chainId, address) {
    return `${chainId}:${address}`;
}
exports.toTokenInChain = toTokenInChain;
function fromTokenInChain(tokenInChain) {
    const [chainId, address] = tokenInChain.split(':');
    return { chainId: parseInt(chainId), address };
}
exports.fromTokenInChain = fromTokenInChain;
function toTrimmedHex(value) {
    const trimmed = (0, viem_1.trim)((0, viem_1.toHex)(value));
    return trimmed.startsWith('0x0') && trimmed !== '0x0' ? trimmed.replace('0x0', '0x') : trimmed;
}
exports.toTrimmedHex = toTrimmedHex;
function splitInChunks(list, chunkSize) {
    const result = [];
    for (let i = 0; i < list.length; i += chunkSize) {
        result.push(list.slice(i, i + chunkSize));
    }
    return result;
}
exports.splitInChunks = splitInChunks;
function toAmountsOfToken({ price, decimals, amount }) {
    const amountInUSD = amountToUSD(decimals, amount, price);
    return {
        amount: BigInt(amount),
        amountInUnits: (0, viem_1.formatUnits)(BigInt(amount), decimals),
        amountInUSD,
    };
}
exports.toAmountsOfToken = toAmountsOfToken;
function isBigIntish(value) {
    return typeof value === 'bigint' || typeof value === 'string' || typeof value === 'number';
}
exports.isBigIntish = isBigIntish;
function groupByChain(elements, map = (elem) => elem) {
    const groupedByChain = {};
    for (const { chainId, ...rest } of elements) {
        if (!(chainId in groupedByChain))
            groupedByChain[chainId] = [];
        groupedByChain[chainId].push(map(rest));
    }
    return groupedByChain;
}
exports.groupByChain = groupByChain;
//# sourceMappingURL=utils.js.map