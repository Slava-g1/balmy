import { TimeString } from '../types';
import { StringValue } from 'ms';
export type ExpirationConfigOptions = {
    useCachedValue: 'always' | {
        ifUnder: StringValue;
    };
    useCachedValueIfCalculationFailed: 'always' | {
        ifUnder: StringValue;
    };
};
export type CacheConfig = {
    expiration: ExpirationConfigOptions;
    maxSize: number;
};
type ValidKey = string | number | symbol;
type CacheConstructorParams<Context, Key extends ValidKey, Value> = {
    calculate: (context: Context, keys: Key[]) => Promise<Record<Key, Value>>;
    config: CacheConfig;
};
export declare class ConcurrentLRUCache<Key extends ValidKey, Value> {
    private readonly cache;
    constructor({ calculate, config, }: {
        calculate: (keys: Key[]) => Promise<Record<Key, Value>>;
    } & {
        config: CacheConfig;
    });
    getOrCalculateSingle({ key, expirationConfig, timeout, }: {
        key: Key;
        expirationConfig?: Partial<ExpirationConfigOptions>;
        timeout?: TimeString;
    }): Promise<Value | undefined>;
    getOrCalculate({ keys, expirationConfig, timeout, }: {
        keys: Key[];
        expirationConfig?: Partial<ExpirationConfigOptions>;
        timeout?: TimeString;
    }): Promise<Record<Key, Value>>;
    holdsValidValue(key: Key, expirationConfig?: ExpirationConfigOptions): boolean;
    holdsValidValues(keys: Key[], expirationConfig?: ExpirationConfigOptions): Record<Key, boolean>;
    invalidate(keys: Key[]): void;
}
export declare class ConcurrentLRUCacheWithContext<Context, Key extends ValidKey, Value> {
    private readonly calculate;
    private readonly storableKeyMapper;
    private readonly expirationConfig;
    private readonly beingCalculated;
    private readonly cache;
    constructor({ calculate, config }: CacheConstructorParams<Context, Key, Value>);
    getOrCalculateSingle({ key, context, expirationConfig, timeout, }: {
        key: Key;
        context: Context;
        expirationConfig?: Partial<ExpirationConfigOptions>;
        timeout?: TimeString;
    }): Promise<Value | undefined>;
    getOrCalculate({ keys, context, expirationConfig, timeout, }: {
        keys: Key[];
        context: Context;
        expirationConfig?: Partial<ExpirationConfigOptions>;
        timeout?: TimeString;
    }): Promise<Record<Key, Value>>;
    holdsValidValue(key: Key, expirationConfig?: ExpirationConfigOptions): boolean;
    holdsValidValues(keys: Key[], expirationConfig?: ExpirationConfigOptions): Record<Key, boolean>;
    invalidate(keys: Key[]): void;
    populate(values: Record<Key, Value>): void;
}
export {};
