"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRequirementsCompatible = exports.couldSupportMeetRequirements = exports.doesResponseMeetRequirements = exports.validateRequirements = exports.combineSupportRecords = exports.combineSupportInChains = exports.combineSourcesSupport = exports.calculateFieldRequirements = exports.calculateFieldRequirementsPerChain = void 0;
const _chains_1 = require("../chains");
function calculateFieldRequirementsPerChain(supportRecord, requirements) {
    const result = {};
    for (const chainId in supportRecord) {
        result[chainId] = calculateFieldRequirements(supportRecord[chainId], requirements);
    }
    return result;
}
exports.calculateFieldRequirementsPerChain = calculateFieldRequirementsPerChain;
function calculateFieldRequirements(supportRecord, requirements) {
    const result = {};
    const fields = new Set([...Object.keys(supportRecord ?? {}), ...Object.keys(requirements?.requirements ?? {})]);
    for (const field of fields) {
        // The idea is simple. We will calculate the requirement for each field in the following order:
        // A. What's specified on the requirements record
        // B. If nothing specified, we will look at the default
        // C. If default is not set, then we fallback to 'best effort'
        //
        // Then, once we know the requirement, we look at the support record
        // A. If the requirement is 'can ignore', then we'll set 'can ignore'
        // B. If the support record says it's present, then we will consider the property 'required', since we expect
        //    it to be there
        // C. If none of the above is true, then we simply fallback to the previously calculated requirement
        const requirement = requirements?.requirements?.[field] ?? requirements?.default ?? 'best effort';
        result[field] = requirement === 'can ignore' || supportRecord?.[field] !== 'present' ? requirement : 'required';
    }
    return result;
}
exports.calculateFieldRequirements = calculateFieldRequirements;
function combineSourcesSupport(sources, extractSupport) {
    const allChains = (0, _chains_1.chainsUnion)(sources.map((source) => Object.keys(extractSupport(source)).map(Number)));
    const result = {};
    for (const chainId of allChains) {
        const supports = sources.map((source) => extractSupport(source)[chainId]).filter((support) => !!support);
        result[chainId] = combineSupportRecords(supports);
    }
    return result;
}
exports.combineSourcesSupport = combineSourcesSupport;
function combineSupportInChains(chainIds, support) {
    const supportsInChains = chainIds.map((chainId) => support[chainId]).filter((support) => !!support);
    return combineSupportRecords(supportsInChains);
}
exports.combineSupportInChains = combineSupportInChains;
function combineSupportRecords(supports) {
    const result = supports[0];
    for (let i = 1; i < supports.length; i++) {
        const sourceSupport = supports[i];
        const allKeys = [...new Set([...Object.keys(sourceSupport), ...Object.keys(result)])];
        for (const key of allKeys) {
            if (result[key] !== sourceSupport[key]) {
                result[key] = 'optional';
            }
        }
    }
    return result;
}
exports.combineSupportRecords = combineSupportRecords;
/**
 * The idea here is that we'll fail if a field is specified as required, but it's not support at all
 * If the field is optional at least, then we won't fail
 */
function validateRequirements(support, chains, requirements) {
    if (!requirements)
        return;
    const supportRecord = combineSupportInChains(chains, support);
    if (!couldSupportMeetRequirements(supportRecord, requirements)) {
        throw new Error(`The provided field requirements cannot be met for all chains`);
    }
}
exports.validateRequirements = validateRequirements;
function doesResponseMeetRequirements(response, requirements) {
    const fieldRequirements = calculateFieldRequirements(undefined, requirements);
    for (const field in fieldRequirements) {
        if (fieldRequirements[field] === 'required' && !(field in (response ?? {}))) {
            return false;
        }
    }
    return true;
}
exports.doesResponseMeetRequirements = doesResponseMeetRequirements;
function couldSupportMeetRequirements(chainSupport, requirements) {
    if (!requirements)
        return true;
    const fieldRequirements = calculateFieldRequirements(chainSupport, requirements);
    for (const key in fieldRequirements) {
        if (fieldRequirements[key] === 'required' && chainSupport?.[key] !== 'present' && chainSupport?.[key] !== 'optional') {
            return false;
        }
    }
    return true;
}
exports.couldSupportMeetRequirements = couldSupportMeetRequirements;
function makeRequirementsCompatible(supportRecord, chains, requirements) {
    if (!requirements)
        return requirements;
    const newRequirements = {};
    const isPropertyPresentOrOptionalInAllChains = (field) => chains.every((chainId) => !!supportRecord[chainId]?.[field]);
    for (const field in requirements.requirements) {
        if (requirements.requirements[field] !== 'required' || isPropertyPresentOrOptionalInAllChains(field)) {
            newRequirements[field] = requirements.requirements[field];
        }
    }
    return { requirements: newRequirements, default: requirements.default };
}
exports.makeRequirementsCompatible = makeRequirementsCompatible;
//# sourceMappingURL=requirements-and-support.js.map